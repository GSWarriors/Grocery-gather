import { Control, ControlProps, ControlState } from '../../controls/Control';
import { ControlInput } from '../../controls/ControlInput';
import { ControlResultBuilder } from '../../controls/ControlResult';
import { InteractionModelContributor } from '../../controls/mixins/InteractionModelContributor';
import { ControlInteractionModelGenerator } from '../../interactionModelGeneration/ControlInteractionModelGenerator';
import { ModelData } from '../../interactionModelGeneration/ModelTypes';
import { ControlResponseBuilder } from '../../responseGeneration/ControlResponseBuilder';
import { InvalidValueAct, UnusableInputValueAct, ValueChangedAct, ValueSetAct, ValueDisconfirmedAct, ValueConfirmedAct } from "../../systemActs/ContentActs";
import { RequestChangedValueByListAct, RequestValueByListAct, ConfirmValueAct } from "../../systemActs/InitiativeActs";
import { SystemAct } from '../../systemActs/SystemAct';
import { StringOrList } from '../../utils/BasicTypes';
import { DeepRequired } from '../../utils/DeepRequired';
import { ValidationResult } from '../../controls/ValidationResult';
export declare type SlotValidationFunction = (state: ListControlState, input: ControlInput) => true | ValidationResult;
export interface ListControlProps extends ControlProps {
    id: string;
    /**
     * The SlotType that this control is collecting.
     *
     * This defines the complete set of choices the user can choose from (regardless of the choices said or shown during elicitation).
     */
    slotType: string;
    /**
     * Determines if the value is valid.
     *
     * Default: `true`, i.e. any value is valid.
     *
     * Usage:
     *  * Validation functions return either `true` or an `errorCode` string.  The `errorCode` can
     *    be converted into a surface form during the render phase.
     */
    validation?: SlotValidationFunction | SlotValidationFunction[];
    /**
     * The list of SlotIds defined by the user as choices for the SlotTypes.
     */
    listItemIDs: string[] | ((input: ControlInput) => string[]);
    /**
     * The number of SlotIds spoken by Alexa from the complete listItemIDs list.
     */
    pageSize?: number;
    /**
     * Whether the Control should elicit the user for a value.
     *
     * Behavior:
     *  - if true, the Control will generate a question when given the opportunity.
     */
    required?: boolean | ((input: ControlInput) => boolean);
    /**
     * Props to customize the relationship between the interaction model and the control.
     */
    interactionModel?: ListControlInteractionModelProps;
    /**
     * Props to customize the prompt-fragments for the system acts produced by the control.
     */
    prompts?: ListControlPromptProps;
    /**
     * Props to customize the reprompt-fragments for the system acts produced by the control.
     */
    reprompts?: ListControlPromptProps;
    /**
     * Props to customize the APL produced
     */
    apl?: ListControlAPLProps;
    /**
     * Whether the Control has to confirm the value which user provides.
     *
     * Behavior:
     *  - if true, the Control will generate a confirmation question when a value is provided.
     */
    confirmationRequired?: boolean | ((input: ControlInput) => boolean);
}
/**
 * Mapping of Action-Slot values to the behaviors that this control supports.
 *
 * Default:
 * ```
 *    {
 *       set: ['set', 'select'],
 *       change: ['change'],
 *    }
 * ```
 */
export interface ListControlActionProps {
    set?: string[];
    change?: string[];
}
export declare class ListControlInteractionModelProps {
    /**
     * Target-slot-values associated with this Control.
     *
     * Usage:
     *  * This allows users to refer to a control.
     *  * A control can be associated with many target-slot-values, eg ['date', 'startDate', 'eventStartDate', 'vacationStart']
     *  * It is a good idea to associate with general targets (e.g. date) and specific targets (e.g. vacationStart) so that the
     *    user can say either general or specific things.  e.g. 'change the date to Tuesday', or 'I want my vacation to start on Tuesday'.
     *  * The association does not have to be exclusive, and general target slot values will often be associated with many controls.
     *    In situations where there is ambiguity about what the user is referring to, the parent controls
     *    must resolve the confusion.
     *
     */
    targets?: string[];
    /**
     * Action-slot-values associated to the action-capabilities of this Control.
     *
     * Default:
     * ```ts
     * {
     *    set: ['set']
     *    change: ['change'],
     * }
     * ```
     *
     * Usage:
     *  * This allows users to refer to an action using more domain-appropriate words. For example, a user might
     *    like to say 'show two items' rather that 'set item count to two'.  To achieve this, include the
     *    slot-value-id 'show' in the list associated with the 'set' capability and ensure the interaction-model
     *    includes an action slot value with id=show and appropriate synonyms.
     *
     * ```
     * {
     *     set: ['set', 'show', 'select']  // Each entry is an action-slot-value that is considered a synonym to 'set' for this control.
     * }
     * ```
     */
    actions?: ListControlActionProps;
}
export declare class ListControlPromptProps {
    valueSet?: StringOrList | ((act: ValueSetAct<any>, input: ControlInput) => StringOrList);
    valueChanged?: StringOrList | ((act: ValueChangedAct<any>, input: ControlInput) => StringOrList);
    invalidValue?: StringOrList | ((act: InvalidValueAct<any>, input: ControlInput) => StringOrList);
    unusableInputValue?: StringOrList | ((act: UnusableInputValueAct<string>, input: ControlInput) => StringOrList);
    requestValue?: StringOrList | ((act: RequestValueByListAct, input: ControlInput) => StringOrList);
    requestChangedValue?: StringOrList | ((act: RequestChangedValueByListAct, input: ControlInput) => StringOrList);
    confirmValue?: StringOrList | ((act: ConfirmValueAct<any>, input: ControlInput) => StringOrList);
    valueDisaffirmed?: StringOrList | ((act: ValueDisconfirmedAct<any>, input: ControlInput) => StringOrList);
    valueAffirmed?: StringOrList | ((act: ValueConfirmedAct<any>, input: ControlInput) => StringOrList);
}
export declare class ListControlAPLProps {
    /**
     * The APL document to use when requesting a value
     *
     * Default: A basic APL TextListLayout document with scrollable and clickable list.
     * See https://developer.amazon.com/en-US/docs/alexa/alexa-presentation-language/apl-alexa-text-list-layout.html
     */
    requestAPLDocument?: {
        [key: string]: any;
    } | ((act: RequestValueByListAct, input: ControlInput) => {
        [key: string]: any;
    });
    /**
     * To indicate if APL needs to be enabled/disabled for the skill.
     */
    enabled?: boolean | ((input: ControlInput) => boolean);
}
export declare class ListControlState implements ControlState {
    /**
     * Value, which is the ID of a SlotValue for this.ValueType.
     */
    value?: string;
    /**
     * Tracks whether an elicitation is happening and whether it is to 'Set' or 'Change' the value.
     */
    elicitationAction?: string;
    /**
     * Tracks whether the value is an Entity Resolution match.
     */
    erMatch?: boolean;
    /**
     * The page index to track the spoken list of SlotIds by Alexa.
     */
    spokenItemsPageIndex?: number;
    /**
     * Tracks whether the value is confirmed by the user, if confirmationRequired is set to true.
     */
    isValueConfirmed: boolean;
    /**
     * Previous value used to track change of a control value.
     */
    previousValue?: string;
    /**
     * Tracks the last initiative act from the control
     */
    lastInitiativeAct?: string;
}
/**
 * Obtains a value of a specific Slot Type using list presentation (voice and visual)
 *
 */
export declare class ListControl extends Control implements InteractionModelContributor {
    rawProps: ListControlProps;
    props: DeepRequired<ListControlProps>;
    state: ListControlState;
    private handleFunc?;
    constructor(props: ListControlProps);
    static mergeWithDefaultProps(props: ListControlProps): DeepRequired<ListControlProps>;
    canHandle(input: ControlInput): boolean;
    handle(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    /**
     * Test if the input is an implicit or explicit set-action with a value provided.
     *
     * @param input
     */
    isSetWithValue(input: ControlInput): boolean;
    handleSetWithValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    /**
     * Test if the input is an implicit or explicit set-action with no value
     *
     * @param input
     */
    isSetWithoutValue(input: ControlInput): boolean;
    handleSetWithoutValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    /**
     * Test if the input is a valid change-action with a value provided.
     *
     * @param input
     */
    isChangeWithValue(input: ControlInput): boolean;
    handleChangeWithValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    /**
     * Test if the input is a valid change-action without a value provided.
     *
     * @param input
     */
    isChangeWithoutValue(input: ControlInput): boolean;
    handleChangeWithoutValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    /**
     * Test if the input is a SingleValueControlIntent with just a slotValue provided.
     * If we aren't asking a question it is assumed the user meant 'set value'.
     * @param input
     */
    isBareValue(input: ControlInput): any;
    handleBareValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    isConfirmationAffirmed(input: ControlInput): any;
    handleConfirmationAffirmed(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    isConfirmationDisAffirmed(input: ControlInput): any;
    handleConfirmationDisAffirmed(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    isOrdinalScreenEvent(input: ControlInput): boolean;
    handleOrdinalScreenEvent(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    isOrdinalSelection(input: ControlInput): boolean;
    handleOrdinalSelection(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    /**
     * Directly set the (new) value for the control
     *
     * After setting the value, it is usual to call
     * ```ts
     * if (control.wantsToDiscussValue()){
     *   control.discussValue()
     * }
     * ```
     * @param value
     */
    setValue(value: string, erMatch: boolean): void;
    clear(): void;
    canTakeInitiative(input: ControlInput): boolean;
    takeInitiative(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    wantsToConfirmValue(input: ControlInput): boolean;
    confirmValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    wantsToFixInvalidValue(input: ControlInput): boolean;
    wantsToElicitValue(input: ControlInput): boolean;
    validateAndAddActs(input: ControlInput, resultBuilder: ControlResultBuilder, elicitationAction: string): void;
    validate(input: ControlInput): true | ValidationResult;
    askElicitationQuestion(elicitationAction: string, input: ControlInput, resultBuilder: ControlResultBuilder): void;
    stringifyStateForDiagram(): string;
    getChoicesList(input: ControlInput): string[];
    getChoicesFromActivePage(allChoices: string[]): string[];
    getPageIndex(): number;
    renderAct(act: SystemAct, input: ControlInput, builder: ControlResponseBuilder): void;
    updateInteractionModel(generator: ControlInteractionModelGenerator, imData: ModelData): void;
    getTargetIds(): string[];
}
//# sourceMappingURL=ListControl.d.ts.map