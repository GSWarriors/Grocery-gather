import { DeepRequired } from '..';
import { Control, ControlProps, ControlState } from '../controls/Control';
import { ControlInput } from '../controls/ControlInput';
import { ControlResultBuilder } from '../controls/ControlResult';
import { InteractionModelContributor } from '../controls/mixins/InteractionModelContributor';
import { ControlInteractionModelGenerator } from '../interactionModelGeneration/ControlInteractionModelGenerator';
import { ModelData } from '../interactionModelGeneration/ModelTypes';
import { ControlResponseBuilder } from '../responseGeneration/ControlResponseBuilder';
import { InformConfusingConfirmationAct, InformConfusingDisconfirmationAct, InvalidValueAct, ProblematicInputValueAct, ValueConfirmedAct, ValueDisconfirmedAct, ValueSetAct } from "../systemActs/ContentActs";
import { ConfirmValueAct, RequestValueAct, SuggestValueAct } from '../systemActs/InitiativeActs';
import { SystemAct } from '../systemActs/SystemAct';
import { StringOrList } from '../utils/BasicTypes';
import { ValidationResult } from '../controls/ValidationResult';
export declare type NumberValidationFunction = (state: NumberControlState, input: ControlInput) => true | ValidationResult;
export declare type NumberConfirmationRequireFunction = (state: NumberControlState, input: ControlInput) => boolean;
export declare type NumberControlActionProps = {
    set?: string[];
    change?: string[];
};
export interface NumberControlInteractionModelProps {
    /**
     * Targets the user can use to refer to this control.
     *
     * Each identifer is an `id` for a value of the `Target` slot in the interaction model.
     *
     * For example, the control may have a target of 'petAge' and an associated entry in the
     * interaction model such as:
     * ```
     * new MyControl(
     *    {
     *      interactionModel: {
     *          targets: ['petAge'],   <---------- 'petAge' is a slot-value ID for the target slot type.
     *      }
     *      ...
     *    }
     *   );
     *
     * ---
     *
     * InteractionModel (en-US.json):
     * ...
     *      types: [
     *              {
     *               name: "target",
     *               values: [
     *                 {
     *                   id: "petAge",        <------   The slot-value ID referenced by the control
     *                   name: {
     *                     value: "petAge",
     *                     synonyms: [
     *                       "Pet's age",
     *                       "My pet's age",
     *                       "Dog's age",
     *                       ...
     * }
     * ```
     */
    targets?: string[];
    /**
     * Action-slot-values associated to the action-capabilities of this Control.
     *
     * Default:
     * ```ts
     * {
     *    set: ['set']
     *    change: ['change'],
     * }
     * ```
     *
     * Usage:
     *  * This allows users to refer to an action using more domain-appropriate words. For example, a user might
     *    like to say 'show two items' rather that 'set item count to two'.  To achieve this, include the
     *    slot-value-id 'show' in the list associated with the 'set' capability and ensure the interaction-model
     *    includes an action slot value with id=show and appropriate synonyms.
     *
     * ```
     * {
     *     set: ['set', 'show', 'select']  // Each entry is an action-slot-value that is considered a synonym to 'set' for this control.
     * }
     * ```
     */
    actions?: NumberControlActionProps;
}
export interface NumberControlProps extends ControlProps {
    id: string;
    interactionModel?: NumberControlInteractionModelProps;
    prompts?: NumberControlPromptsProps;
    reprompts?: NumberControlPromptsProps;
    required?: boolean | ((input: ControlInput) => boolean);
    /**
     * List of validation functions to check if the user input number is valid.
     */
    validation?: NumberValidationFunction | NumberValidationFunction[];
    /**
     * Inputs that do not require confirmation. All values need to be confirmed if this is not provided.
     */
    confirmationRequired?: boolean | NumberConfirmationRequireFunction;
    /**
     * List of duals that once one of them is not affirmed, the other will be prompted for confirmation.
     */
    ambiguousPairs?: Array<[number, number]>;
}
export interface NumberControlPromptsProps {
    requestValue?: StringOrList | ((act: RequestValueAct, input: ControlInput) => StringOrList);
    confirmValue?: StringOrList | ((act: ConfirmValueAct<number>, input: ControlInput) => StringOrList);
    valueDisaffirmed?: StringOrList | ((act: ValueDisconfirmedAct<number>, input: ControlInput) => StringOrList);
    valueSet?: StringOrList | ((act: ValueSetAct<number>, input: ControlInput) => StringOrList);
    valueAffirmed?: StringOrList | ((act: ValueConfirmedAct<number>, input: ControlInput) => StringOrList);
    suggestValue?: StringOrList | ((act: SuggestValueAct<number>, input: ControlInput) => StringOrList);
    informConfusingDisconfirmation?: StringOrList | ((act: InformConfusingDisconfirmationAct<number>, input: ControlInput) => StringOrList);
    informConfusingConfirmation?: StringOrList | ((act: InformConfusingConfirmationAct<number>, input: ControlInput) => StringOrList);
    repeatUnusableValue?: StringOrList | ((act: ProblematicInputValueAct<number>, input: ControlInput) => StringOrList);
    invalidValue?: StringOrList | ((act: InvalidValueAct<number>, input: ControlInput) => StringOrList);
}
export declare class NumberControlState implements ControlState {
    value?: number;
    isValueConfirmed: boolean;
    rejectedValues: number[];
}
/**
 * Main class for NumberControl.
 * For constructor parameters please read the interface @NumberControlProps .
 */
export declare class NumberControl extends Control implements InteractionModelContributor {
    rawProps: NumberControlProps;
    props: DeepRequired<NumberControlProps>;
    state: NumberControlState;
    handleFunc?: (input: ControlInput, resultBuilder: ControlResultBuilder) => void;
    constructor(props: NumberControlProps);
    static mergeWithDefaultProps(props: NumberControlProps): DeepRequired<NumberControlProps>;
    canHandle(input: ControlInput): boolean;
    handle(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    canTakeInitiative(input: ControlInput): boolean;
    takeInitiative(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    renderAct(act: SystemAct, input: ControlInput, builder: ControlResponseBuilder): void;
    updateInteractionModel(generator: ControlInteractionModelGenerator, imData: ModelData): void;
    getTargetIds(): string[];
    private canHandleForEmptyStateValue;
    private handleLastQuestionEmptyAndValueNotExisting;
    private handleLastQuestionEmptyAndValueExisting;
    private canHandleForExistingStateValue;
    private isValueInRejectedValues;
    private handleValueExistsInRejectedValues;
    private isBareNoWhenConfirmingValue;
    private isFeedbackNoAndValueUndefinedWhenConfirmingValue;
    private handleFeedbackNoAndWithoutValueWhenConfirmingValue;
    private isFeedbackNoAndValueNotChangedWhenConfirmingValue;
    private handleFeedbackNoAndValueNotChangedWhenConfirmingValue;
    private isFeedbackNoAndValueChangedWhenConfirmingValue;
    private handleFeedbackNoAndValueChangedWhenConfirmingValue;
    private isFeedbackYesAndValueChangedWhenConfirmingValue;
    private handleFeedbackYesAndValueChangedWhenConfirmingValue;
    private isBareYesConfirmingValue;
    private isFeedbackYesAndValueNotChangedWhenConfirmingValue;
    private isFeedbackYesAndValueUndefinedWhenConfirmingValue;
    private handleFeedbackYesAndValueNotChangedOrUndefinedWhenConfirmingValue;
    private isFeedbackUndefinedAndValueNotChangedWhenConfirmingValue;
    private handleFeedbackYesAndValueUndefinedWhenConfirmingValue;
    private isFeedbackUndefinedAndValueChangedWhenConfirmingValue;
    private handleFeedbackUndefinedAndValueChangedWhenConfirmingValue;
    private isTargetsMatchWithoutFeedbackNorValueWhenConfirmingValue;
    private handleTargetMatchWithoutFeedbackNorValueWhenConfirmingValue;
    private commonHandlerWhenValueChanged;
    /**
     * TODO: User's action has to be used in this function to form the response prompt, need to define action in the related payloadType
     *
     * U: No, {change} the value please
     * A: What value do you want to {change} to <RequestValueAct>
     */
    private commonHandlerWhenValueRejected;
    private wantsToElicitValue;
    private wantsToFixInvalidValue;
    private wantsToConfirmValue;
    clear(): void;
    setValue(value: string | number): void;
    private validateNumber;
    private isConfirmationRequired;
    private getAmbiguousPartner;
}
//# sourceMappingURL=NumberControl.d.ts.map