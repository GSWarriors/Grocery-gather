import { Control, ControlProps, ControlState } from '../controls/Control';
import { ControlInput } from '../controls/ControlInput';
import { ControlResultBuilder } from '../controls/ControlResult';
import { InteractionModelContributor } from '../controls/mixins/InteractionModelContributor';
import { GeneralControlIntent } from '../intents/GeneralControlIntent';
import { SingleValueControlIntent } from '../intents/SingleValueControlIntent';
import { ControlInteractionModelGenerator } from '../interactionModelGeneration/ControlInteractionModelGenerator';
import { ModelData } from '../interactionModelGeneration/ModelTypes';
import { ControlResponseBuilder } from '../responseGeneration/ControlResponseBuilder';
import { InvalidValueAct, ValueChangedAct, ValueSetAct, ValueDisconfirmedAct, ValueConfirmedAct } from "../systemActs/ContentActs";
import { RequestChangedValueAct, RequestValueAct, ConfirmValueAct } from "../systemActs/InitiativeActs";
import { SystemAct } from '../systemActs/SystemAct';
import { StringOrList } from '../utils/BasicTypes';
import { DeepRequired } from '../utils/DeepRequired';
import { ValidationResult } from '../controls/ValidationResult';
export declare type DateValidationFunction = (state: DateControlState, input: ControlInput) => true | ValidationResult;
export declare type DateControlActionProps = {
    /**
     * Action slot-values the user can use to refer to the `set` action-capability of this control.
     *
     * Each identifer is an `id` for a value of the `Action` slot type in the interaction model.
     *
     * Purpose:
     * * This flexibility is useful when an action verb (such as 'show') might have different meaning to different controls.
     * * If the flexibility is not required it is sufficient to add synonyms to the standard "set" action-slot-value.
     *
     * Example:
     * The control instance below use this prop to represent that 'show tuesday' is equivalent
     * to 'set the date to tuesday' for this control.
     *
     *
     * ```
     * new DateControl(
     *    {
     *      nlu: {
     *          actions: {
     *              set: ['show']       <------   'show' is a slot ID for the action slot-type.
     *          },
     *      }
     *      ...
     *    }
     *   );
     *
     * ---
     *
     * InteractionModel (en-US.json):
     * ...
     *      types: [
     *              {
     *               name: "actions",
     *               values: [
     *                 {
     *                   id: "show",        <------   ID referenced by the control
     *                   name: {
     *                     value: "show",
     *                       ...
     * }
     * ```
     */
    set?: string[];
    /**
     * Action slot-values the user can use to refer to the `change` action-capability of this control.
     *
     * Each identifer is an `id` for a value of the `Action` slot in the interaction model.
     *
     * Purpose:
     * * This flexibility is useful when an action verb (such as 'update') might have different meaning to different controls.
     * * If the flexibility is not required it is sufficient to add synonyms to the standard "change" action-slot-value.
     *
     * Further information
     *  * See the `set` property for more information.
     */
    change?: string[];
};
export interface DateControlPromptProps {
    valueSet?: StringOrList | ((act: ValueSetAct<number>, input: ControlInput) => StringOrList);
    valueChanged?: StringOrList | ((act: ValueChangedAct<number>, input: ControlInput) => StringOrList);
    invalidValue?: StringOrList | ((act: InvalidValueAct<number>, input: ControlInput) => StringOrList);
    requestValue?: StringOrList | ((act: RequestValueAct, input: ControlInput) => StringOrList);
    requestChangedValue?: StringOrList | ((act: RequestChangedValueAct, input: ControlInput) => StringOrList);
    confirmValue?: StringOrList | ((act: ConfirmValueAct<number>, input: ControlInput) => StringOrList);
    valueDisaffirmed?: StringOrList | ((act: ValueDisconfirmedAct<number>, input: ControlInput) => StringOrList);
    valueAffirmed?: StringOrList | ((act: ValueConfirmedAct<number>, input: ControlInput) => StringOrList);
}
export interface DateControlProps extends ControlProps {
    id: string;
    prompts?: DateControlPromptProps;
    reprompts?: DateControlPromptProps;
    /**
     * Props to customize the relationship between the interaction model and the control.
     */
    interactionModel?: DateControlInteractionModelProps;
    /**
     * Determines if the value is valid.
     *
     * Default: `true`, i.e. any value is valid.
     *
     * Usage:
     *  * Validation functions return either `true` or an `errorCode` string.  The `errorCode` can
     *    be converted into a surface form during the render phase.
     *  * Common validation functions are defined in the `DateControlValidations` namespace
     *    which can be added directly to this prop. e.g.:
     * ```
     *    valid: DateControlValidations.FUTURE_DATE_ONLY,
     * ```
     */
    validation?: DateValidationFunction | DateValidationFunction[];
    /**
     * Determines if the value collected by this Control is required by the skill.
     *
     * Behavior:
     *  * If `required = true`, the control will take the initiative to request a value from the user.
     */
    required?: boolean | ((input: ControlInput) => boolean);
    /**
     * Whether the Control has to confirm the value which user provides.
     *
     * Behavior:
     *  - if true, the Control will generate a confirmation question when a value is provided.
     */
    confirmationRequired?: boolean | ((input: ControlInput) => boolean);
}
export interface DateControlInteractionModelProps {
    /**
     * Targets the user can use to refer to a this control.
     *
     * Each identifer is an `id` for a value of the `Target` slot in the interaction model.
     *
     * For example, the control may have a target of 'petAge' and an associated entry in the
     * interaction model such as:
     * ```
     * new MyControl(
     *    {
     *      nlu: {
     *          targets: ['petAge'],   <---------- Reference to slot ID
     *      }
     *      ...
     *    }
     *   );
     *
     * ---
     *
     * InteractionModel (en-US.json):
     * ...
     *      types: [
     *              {
     *               name: "target",
     *               values: [
     *                 {
     *                   id: "petAge",        <------   ID referenced by the control
     *                   name: {
     *                     value: "petAge",
     *                     synonyms: [
     *                       "Pet's age",
     *                       "My pet's age",
     *                       "Dog's age",
     *                       ...
     * }
     * ```
     */
    targets?: string[];
    /**
     * Action-slot-values associated to the action-capabilities of this Control.
     *
     * Default:
     * ```ts
     * {
     *    set: ['set']
     *    change: ['change'],
     * }
     * ```
     *
     * Usage:
     *  * This allows users to refer to an action using more domain-appropriate words. For example, a user might
     *    like to say 'show two items' rather that 'set item count to two'.  To achieve this, include the
     *    slot-value-id 'show' in the list associated with the 'set' capability and ensure the interaction-model
     *    includes an action slot value with id=show and appropriate synonyms.
     *
     * ```
     * {
     *     set: ['set', 'show', 'select']  // Each entry is an action-slot-value that is considered a synonym to 'set' for this control.
     * }
     * ```
     */
    actions?: DateControlActionProps;
}
export declare enum DateValidationFailReasonCode {
    PAST_DATE_ONLY = "pastDateOnly",
    FUTURE_DATE_ONLY = "futureDateOnly"
}
export declare namespace DateControlValidations {
    const PAST_DATE_ONLY: DateValidationFunction;
    const FUTURE_DATE_ONLY: DateValidationFunction;
}
export declare class DateControlState implements ControlState {
    /**
     * Value, which is the ID of a SlotValue for this.ValueType.
     */
    value?: string;
    /**
     * Tracks whether an elicitation is happening and whether it is to 'Set' or 'Change' the value.
     */
    elicitationAction?: string;
    /**
     * Tracks whether the value is confirmed by the user, if confirmationRequired is set to true.
     */
    isValueConfirmed: boolean;
    /**
     * Previous value used to track change of a control value.
     */
    previousValue?: string;
    /**
     * Tracks the last initiative act from the control
     */
    lastInitiativeAct?: string;
}
export declare class DateControl extends Control implements InteractionModelContributor {
    rawProps: DateControlProps;
    props: DeepRequired<DateControlProps>;
    state: DateControlState;
    private handleFunc?;
    supportedControlIntents: (SingleValueControlIntent | GeneralControlIntent)[];
    constructor(props: DateControlProps);
    static mergeWithDefaultProps(props: DateControlProps): DeepRequired<DateControlProps>;
    canHandle(input: ControlInput): boolean;
    /**
     * Test if the input is an implicit or explicit set-action with a value provided.
     *
     * @param input
     */
    isSetWithValue(input: ControlInput): boolean;
    handleSetWithValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    /**
     * Test if the input is an implicit or explicit set-action with no value
     *
     * @param input
     */
    isSetWithoutValue(input: ControlInput): boolean;
    handleSetWithoutValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    /**
     * Test if the input is a valid change-action with a value provided.
     *
     * @param input
     */
    isChangeWithValue(input: ControlInput): boolean;
    handleChangeWithValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    /**
     * Test if the input is a valid change-action without a value provided.
     *
     * @param input
     */
    isChangeWithoutValue(input: ControlInput): boolean;
    handleChangeWithoutValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    /**
     * Test if the input is a DateControlIntent with just a date provided.
     * If we aren't asking a question it is assumed the user meant 'set value'.
     * @param input
     */
    isBareValue(input: ControlInput): any;
    handleBareValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    isConfirmationAffirmed(input: ControlInput): any;
    handleConfirmationAffirmed(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    isConfirmationDisAffirmed(input: ControlInput): any;
    handleConfirmationDisAffirmed(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    handle(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    canTakeInitiative(input: ControlInput): boolean;
    takeInitiative(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    wantsToElicitValue(input: ControlInput): boolean;
    askElicitationQuestion(elicitationAction: string, input: ControlInput, resultBuilder: ControlResultBuilder): void;
    validateAndAddActs(input: ControlInput, resultBuilder: ControlResultBuilder, elicitationAction: string): void;
    wantsToConfirmValue(input: ControlInput): boolean;
    confirmValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    wantsToFixInvalidValue(input: ControlInput): boolean;
    validate(input: ControlInput): true | ValidationResult;
    setValue(value: string): void;
    clear(): void;
    renderAct(act: SystemAct, input: ControlInput, builder: ControlResponseBuilder): void;
    updateInteractionModel(generator: ControlInteractionModelGenerator, imData: ModelData): void;
    getTargetIds(): string[];
}
//# sourceMappingURL=DateControl.d.ts.map