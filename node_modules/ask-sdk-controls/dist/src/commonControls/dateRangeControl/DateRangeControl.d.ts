import { InvalidValueAct, ContentAct } from "../../systemActs/ContentActs";
import { Control } from '../../controls/Control';
import { RequestValueAct } from '../../systemActs/InitiativeActs';
import { SystemAct } from '../../systemActs/SystemAct';
import { ControlInput } from '../../controls/ControlInput';
import { ControlResultBuilder } from '../../controls/ControlResult';
import { ControlResponseBuilder } from '../../responseGeneration/ControlResponseBuilder';
import { ControlInteractionModelGenerator } from '../../interactionModelGeneration/ControlInteractionModelGenerator';
import { InteractionModelContributor } from '../../controls/mixins/InteractionModelContributor';
import { ModelData } from '../../interactionModelGeneration/ModelTypes';
import { ContainerControl, ContainerControlProps, ContainerControlState } from '../../controls/ContainerControl';
import { DateControl, DateControlPromptProps, DateValidationFunction } from '../DateControl';
import { StringOrList } from '../..';
import { DeepRequired } from '../../utils/DeepRequired';
import { ValidationResult } from '../../controls/ValidationResult';
export declare type DateRangeValidationFunction = ((state: DateRangeControlState, input: ControlInput) => true | ValidationResult);
export interface DateRangeControlPromptProps {
    startDate?: DateControlPromptProps;
    endDate?: DateControlPromptProps;
    requestRange?: StringOrList | ((act: RequestValueAct, input: ControlInput) => StringOrList);
    rangeSet?: StringOrList | ((act: DateRangeSetAct, input: ControlInput) => StringOrList);
    rangeChanged?: StringOrList | ((act: DateRangeChangedAct, input: ControlInput) => StringOrList);
    invalidRange?: StringOrList | ((act: InvalidValueAct<string>, input: ControlInput) => StringOrList);
}
export interface DateRangeControlInteractionModelProps {
    /**
     * Target-slot-values associated with this Control.
     *
     * Usage:
     *  * This allows users to refer to a control.
     *  * A control can be associated with many target-slot-values, eg ['date', 'startDate', 'eventStartDate', 'vacationStart']
     *  * It is a good idea to associate with general targets (e.g. date) and specific targets (e.g. vacationStart) so that the
     *    user can say either general or specific things.  e.g. 'change the date to Tuesday', or 'I want my vacation to start on Tuesday'.
     *  * The association does not have to be exclusive, and general target slot values will often be associated with many controls.
     *    In situations where there is ambiguity about what the user is referring to, the parent controls
     *    must resolve the confusion.
     *
     */
    targets?: DateRangeControlTargetProps;
    /**
     * Action-slot-values associated to the capabilities of this Control.
     *
     * Usage:
     *  * This allows users to refer to an action using more domain-appropriate words. For example, a user might
     *    like to say 'show two items' rather that 'set item count to two'.  To achieve this, associate the
     *    slot value 'show' to the 'set' capability like so:
     *
     * ```ts
     * actions: {
     *    set: ['set', 'show']
     * }
     * ```
     */
    actions?: DateRangeControlActionProps;
}
export declare type DateRangeControlTargetProps = {
    /**
     * Targets the user can use to refer to the 'date range' in general.
     *
     * Each identifer is an `id` for a value of the `Target` slot in the interaction model.
     *
     * For example, a control may have a target of 'username' and an associated entry in the
     * interaction model such as:
     * ```
     * new DateRangeControl(
     *    {
     *      interactionModel: {
     *          targets: ['eventDates']   <---------- Reference to slot ID
     *      }
     *      ...
     *    }
     *   );
     *
     * ---
     *
     * InteractionModel (en-US.json):
     * ...
     *      types: [
     *              {
     *               name: "target",
     *               values: [
     *                 {
     *                   id: "eventDates",        <------   ID referenced by the control
     *                   name: {
     *                     value: "eventDates",
     *                     synonyms: [
     *                       "Event dates",
     *                       "the event dates",
     *                       "my event dates",
     *                       ...
     * }
     * ```
     */
    self?: string[];
    /**
     * Targets the user can use to refer to the `start date` in isolation.
     *
     * Each identifer is an `id` for a value of the `Target` slot in the interaction model.
     *
     * For example, a control may have a target of 'eventStartDate' and an associated entry in the
     * interaction model such as:
     * ```
     * new DateRangeControl(
     *    {
     *      interactionModel: {
     *          targets: ['eventStartDate'],        <------   Reference to slot ID
     *          ...
     *      }
     *    }
     *   );
     *
     * ---
     *
     * InteractionModel (en-US.json):
     * ...
     *      types: [
     *              {
     *               name: "target",
     *               values: [
     *                 {
     *                   id: "eventStartDate",        <------   ID referenced by the control
     *                   name: {
     *                     value: "eventStartDate",
     *                     synonyms: [
     *                       "event start date",
     *                       "event start",
     *                       "start of event",
     *                       ...
     * }
     * ```
     */
    startDate?: string[];
    /**
     * Targets the user can use to refer to the `end date` in isolation.
     *
     * Each identifer is an `id` for a value of the `Target` slot in the interaction model.
     *
     * For example, a control may have a target of 'eventEndDate' and an associated entry in the
     * interaction model such as:
     * ```
     * new DateRangeControl(
     *    {
     *      interactionModel: {
     *          targets: ['eventEndDate'],        <------   Reference to slot ID
     *          ...
     *      }
     *    }
     *   );
     *
     * ---
     *
     * InteractionModel (en-US.json):
     * ...
     *      types: [
     *              {
     *               name: "target",
     *               values: [
     *                 {
     *                   id: "eventEndDate",        <------   ID referenced by the control
     *                   name: {
     *                     value: "eventStartDate",
     *                     synonyms: [
     *                       "event end date",
     *                       "event end",
     *                       "end of event",
     *                       ...
     * }
     * ```
     */
    endDate?: string[];
};
export interface DateRangeControlProps extends ContainerControlProps {
    id: string;
    prompts?: DateRangeControlPromptProps;
    reprompts?: DateRangeControlPromptProps;
    interactionModel?: DateRangeControlInteractionModelProps;
    /**
     * Determines if the value is valid.
     *
     * Default: `true`, i.e. any value is valid.
     *
     * Usage:
     *  * Validation functions return either `true` or an `errorCode` string.  The `errorCode` can
     *    be converted into a surface form during the render phase.
     *  * Common validation functions are defined in the `DateRangeControlValidations` namespace
     *    which can be added directly to this prop. e.g.:
     * ```
     *    valid: DateRangeControlValidations.START_BEFORE_END,
     * ```
     */
    validation?: {
        startDateValid?: DateValidationFunction | DateValidationFunction[];
        endDateValid?: DateValidationFunction | DateValidationFunction[];
        rangeValid?: DateRangeValidationFunction | DateRangeValidationFunction[];
    };
    /**
     * When there is no on going question, should DateRangeControl
     * spontaneously ask for date range info if it's not invoked in previous dialog turns
     */
    required?: boolean | ((input: ControlInput) => boolean);
}
export interface DateRangeControlActionProps {
    set?: string[];
    change?: string[];
}
export declare namespace DateRangeControlValidations {
    const START_BEFORE_END: DateRangeValidationFunction;
}
export declare class DateRangeControlState extends ContainerControlState {
    startDate?: string;
    endDate?: string;
    priorStartDate?: string;
    priorEndDate?: string;
    openQuestion: boolean;
    onFocus: boolean;
}
export declare enum TargetCategory {
    StartDate = "startDate",
    EndDate = "endDate",
    Both = "both",
    Neither = "neither",
    Either = "either"
}
export declare enum DateControlTarget {
    StartDate = "startDate",
    EndDate = "endDate"
}
export declare class DateRangeSetAct extends ContentAct {
    readonly startDate: string | undefined;
    readonly endDate: string | undefined;
    constructor(control: Control, start: string | undefined, end: string | undefined);
    render(input: ControlInput, responseBuilder: ControlResponseBuilder): void;
}
export declare class DateRangeChangedAct extends ContentAct {
    readonly startDate: string | undefined;
    readonly endDate: string | undefined;
    readonly priorStartDate: string | undefined;
    readonly priorEndDate: string | undefined;
    constructor(control: Control, start: string | undefined, end: string | undefined, priorStart: string | undefined, priorEnd: string | undefined);
    render(input: ControlInput, responseBuilder: ControlResponseBuilder): void;
}
export declare class DateRangeControl extends ContainerControl implements InteractionModelContributor {
    startDateControl: DateControl;
    endDateControl: DateControl;
    state: DateRangeControlState;
    props: DeepRequired<DateRangeControlProps>;
    children: DateControl[];
    handleFunc: ((input: ControlInput, resultBuilder: ControlResultBuilder) => void) | undefined;
    takeInitiativeFunc: ((input: ControlInput, resultBuilder: ControlResultBuilder) => void) | undefined;
    static mergeWithDefaultProps(props: DateRangeControlProps): DeepRequired<DateRangeControlProps>;
    constructor(props: DateRangeControlProps);
    canHandle(input: ControlInput): Promise<boolean>;
    handle(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    updateInteractionModel(generator: ControlInteractionModelGenerator, imData: ModelData): void;
    getTargetIds(): string[];
    getStartDateFromChild(): string | undefined;
    getEndDateFromChild(): string | undefined;
    setStartDate(date: string | undefined): void;
    setEndDate(date: string | undefined): void;
    canHandleForFocus(input: ControlInput): Promise<boolean>;
    canHandleForNoFocus(input: ControlInput): Promise<boolean>;
    /**
     * Test if the input has both start date and end date provided
     * @param input
     */
    isTwoValueInput(input: ControlInput): boolean;
    handleTwoValueInput(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    /**
     * Determine whether the input single date value should be considered as date range
     *
     * The DateRangeControl will regard a single value input as date range when there's no clear target and
     * when the DateRangeControl itself is under focus
     * E.G. 'set range to 2018', where 2018 will be regarded as a range and both start date and end date will be set to 2018
     * @param input
     */
    isDateInterpretedAsDateRange(input: ControlInput): boolean;
    handleDateRangeInput(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    /**
     * Determine whether the input action is targeting both start date and end date
     *
     * E.G. 'Change start date and end date'
     * @param input
     */
    isChangeBoth(input: ControlInput): boolean;
    /**
     * Determine whether the input action is targeting date range
     *
     * E.G. 'Change', 'Change date'
     * @param input
     */
    isChangeRange(input: ControlInput): boolean;
    handleChangeValue(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    private updatePrior;
    private ackDateRangeValueChanges;
    validateDateRange(input: ControlInput): true | ValidationResult;
    renderAct(act: SystemAct, input: ControlInput, builder: ControlResponseBuilder): void;
    canTakeInitiative(input: ControlInput): Promise<boolean>;
    takeInitiative(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    needsValue(input: ControlInput): boolean;
    requestDateRange(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    hasOpenQuestion(): boolean;
    wantsToCorrectRange(input: ControlInput): boolean;
    correctRange(input: ControlInput, resultBuilder: ControlResultBuilder): void;
    canTakeInitiativeByChild(input: ControlInput): Promise<boolean>;
}
//# sourceMappingURL=DateRangeControl.d.ts.map