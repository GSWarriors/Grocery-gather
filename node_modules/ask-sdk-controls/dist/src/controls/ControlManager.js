"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateIMForControl = exports.renderActsInSequence = exports.ControlManager = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const LanguageStrings_1 = require("../commonControls/LanguageStrings");
const Control_1 = require("../controls/Control");
const InteractionModelContributor_1 = require("../controls/mixins/InteractionModelContributor");
const ControlInteractionModelGenerator_1 = require("../interactionModelGeneration/ControlInteractionModelGenerator");
const Logger_1 = require("../logging/Logger");
const IContainerControl_1 = require("./interfaces/IContainerControl");
const i18next_1 = tslib_1.__importDefault(require("i18next"));
const log = new Logger_1.Logger('AskSdkControls:ControlManager');
/**
 * Defining the high-level functionality for a skill built with Controls.
 *
 * Each skill should define a concrete sub-class that implements `createControlTree` and optionally override other methods.
 *
 * Summary:
 *  * createControlTree() creates a hierarchy of controls that cooperatively manage the skill behavior.
 *   * the methods on the root control will be called to process the user's input and to generate system initiative.
 *   * The Control tree forms the Controller and the Model of the skill.
 *
 *  * render() is the entry-point for the render-phase, aka the View layer.
 *   * typically the render method will delegate to Controls and/or Acts for fine-grained rendering, but it is
 *     legal to do the rendering by any means such as by calling out to a natural-language-generation algorithm or service.
 *
 *  * `render()` builds up the output using a `ControlResponseBuilder` which is ultimately used to build a regular Alexa SDK Response object
 *
 *  * Information is passed between the Controller and the View in the form of a `ControlResult`.  The `ControlResult` comprises
 *    a list of SystemActs that describe *what* should be communicated to the user but generally should not describe *how* to present it.
 *
 *  * `handleInternalError` provides an entry-point for custom handling of internal errors.
 *
 *  * `buildInteractionModel` provides an entry-point for building the Control-specific aspects of skill's Interaction Model.
 *
 * Internationalization and Localization
 *  * Controls themselves are location-agnostic.  They consume abstract inputs (Intents, etc) and produce abstract outputs (SystemActs)
 *
 *  * Mapping localized input to abstract inputs is the role of NLU and the necessary information is stored in the Interaction Model
 *   * The ControlManager props includes a bag of localization data that is used during interaction-model building for a given locale
 *   * The framework ships with a default set of interaction model data for en-US
 *
 *  * Mapping abstract output to physical output (prompts, APL strings) etc is the role of the rendering phase.  This information is
 *    part of the skill definition but can be located in various places: either in a monolithic render() function, or scattered around
 *    the Controls and Acts in the form of props.
 *
 *   See /doc/... for more information  // TODO: update with precise link
 */
class ControlManager {
    /**
     * Creates an instance of a Control Manager.
     * @param props
     */
    constructor(props) {
        this.props = ControlManager.mergeWithDefaultProps(props);
        const resource = lodash_1.default.merge(LanguageStrings_1.systemResource, this.props.i18nOverride);
        i18nInit(this.props.locale, resource);
    }
    static mergeWithDefaultProps(props) {
        const defaults = {
            locale: 'en-US',
            i18nOverride: {}
        };
        return lodash_1.default.mergeWith(defaults, props);
    }
    /**
     * Transforms the information in ControlResult into user-facing content (prompts and APL).
     *
     * Default: The default rendering strategy renders each `SystemAct` in turn by calling `act.control.render(act)`.
     *          This strategy leads to prompts that are a concatenation of the prompt-fragment for each `SystemAct`.
     *
     * Usage:
     *  * In many situations rendering the acts one-by-one is sufficient as the concatenation of prompt fragments
     *    leads to usable prompts.  For example [ValueSetAct(ageCtrl, 5), RequestValueAct(nameCtrl)] -> 'OK, 5. What is your name?"
     *
     *  * For more complex situations, override this method and implement a custom rendering strategy.  Often the solution will
     *    be to implement some special cases and otherwise fallback to the default by calling super.render() or by directly calling
     *    `ControlManager.renderActsOneByOne()`.
     *
     */
    render(result, input, controlResponseBuilder) {
        renderActsInSequence(result.acts, input, controlResponseBuilder);
    }
    /**
     * Handle an internal error.
     *
     * This is only for logging, reporting and perhaps mentioning the situation to the user.
     * The user session will be closed.
     *
     * Default: The error object is converted into an object with enumerable properties and logged at logLevel=error
     * @param input
     * @param error
     * @param responseBuilder
     */
    handleInternalError(input, error, responseBuilder) {
        const err = error.stack !== undefined ? { name: error.name, msg: error.message, stack: error.stack } : error; // Error doesn't have enumerable properties, so we convert it.
        log.error(`Error handled: ${JSON.stringify(err)}`);
    }
    /**
     * Builds interaction model content for the Control Tree
     *
     * Usage:
     * * The imDataMap has 'en-US' modelData registered by default
     * * The developer may configure and register additional `imDataMap` instances to support additional locales
     *
     * * If imDataMap doesn't have data for the requested locale a `LocaleNotSupportedError` will be thrown
     *
     * @param generator Interaction Model Generator
     * @param locale The locale code, E.G. 'en-US', 'de-DE', 'ja-JP'. REF: https://developer.amazon.com/en-US/docs/alexa/custom-skills/develop-skills-in-multiple-languages.html#h2-code-changes
     */
    buildInteractionModel(generator) {
        const rootControl = this.createControlTree({});
        const imData = ControlInteractionModelGenerator_1.generateModelData();
        updateIMForControl(generator, rootControl, imData);
    }
}
exports.ControlManager = ControlManager;
/**
 * Render each of the acts, one-by-one.
 *
 *
 * @param systemActs The system acts to render
 * @param context
 * @param responseBuilder
 */
function renderActsInSequence(systemActs, input, controlResponseBuilder) {
    for (const act of systemActs) {
        act.control.renderAct(act, input, controlResponseBuilder);
    }
}
exports.renderActsInSequence = renderActsInSequence;
/**
 * Go through the entire control tree and update IM
 * @param generator
 * @param control
 * @param locale
 */
function updateIMForControl(generator, control, imData) {
    if (control instanceof Control_1.Control && InteractionModelContributor_1.implementsInteractionModelContributor(control)) {
        control.updateInteractionModel(generator, imData);
        const targetIds = control.getTargetIds();
        if (targetIds !== undefined) {
            targetIds.forEach((targetId) => {
                generator.targetSlotIds = generator.targetSlotIds.add(targetId);
            });
        }
    }
    // If container control, do same thing recursively
    if (IContainerControl_1.isContainerControl(control)) {
        for (const child of control.children) {
            updateIMForControl(generator, child, imData);
        }
    }
}
exports.updateIMForControl = updateIMForControl;
function i18nInit(locale, resources) {
    if (!locale) {
        throw new Error('Please specify the language.');
    }
    void i18next_1.default.init({
        lng: locale,
        resources,
        fallbackLng: 'en',
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udHJvbE1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29udHJvbHMvQ29udHJvbE1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7OztHQVdHOzs7O0FBR0gsNERBQXVCO0FBQ3ZCLHVFQUFtRTtBQUNuRSxpREFBOEM7QUFDOUMsZ0dBQXVHO0FBQ3ZHLHFIQUFxSTtBQUVySSw4Q0FBMkM7QUFLM0Msc0VBQW9FO0FBR3BFLDhEQUE4QjtBQUk5QixNQUFNLEdBQUcsR0FBRyxJQUFJLGVBQU0sQ0FBQywrQkFBK0IsQ0FBQyxDQUFDO0FBVXhEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQW1DRztBQUNILE1BQXNCLGNBQWM7SUFhaEM7OztPQUdHO0lBQ0gsWUFBWSxLQUEyQjtRQUNuQyxJQUFJLENBQUMsS0FBSyxHQUFHLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN6RCxNQUFNLFFBQVEsR0FBYSxnQkFBQyxDQUFDLEtBQUssQ0FBQyxnQ0FBYyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDNUUsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFqQkQsTUFBTSxDQUFDLHFCQUFxQixDQUFDLEtBQXNDO1FBQy9ELE1BQU0sUUFBUSxHQUFrQztZQUM1QyxNQUFNLEVBQUUsT0FBTztZQUNmLFlBQVksRUFBRSxFQUFFO1NBQ25CLENBQUM7UUFFRixPQUFPLGdCQUFDLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN4QyxDQUFDO0lBNkJEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBQ0gsTUFBTSxDQUFDLE1BQXFCLEVBQUUsS0FBbUIsRUFBRSxzQkFBOEM7UUFDN0Ysb0JBQW9CLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxLQUFLLEVBQUUsc0JBQXNCLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILG1CQUFtQixDQUFDLEtBQW1CLEVBQUUsS0FBVSxFQUFFLGVBQWdDO1FBQ2pGLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsT0FBTyxFQUFFLEtBQUssRUFBRSxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLDhEQUE4RDtRQUM1SyxHQUFHLENBQUMsS0FBSyxDQUFDLGtCQUFrQixJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDSCxxQkFBcUIsQ0FBQyxTQUEyQztRQUM3RCxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDL0MsTUFBTSxNQUFNLEdBQWMsb0RBQWlCLEVBQUUsQ0FBQztRQUM5QyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsV0FBVyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3ZELENBQUM7Q0FDSjtBQTVGRCx3Q0E0RkM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsU0FBZ0Isb0JBQW9CLENBQUMsVUFBdUIsRUFBRSxLQUFtQixFQUFFLHNCQUE4QztJQUM3SCxLQUFLLE1BQU0sR0FBRyxJQUFJLFVBQVUsRUFBRTtRQUMxQixHQUFHLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLHNCQUFzQixDQUFDLENBQUM7S0FDN0Q7QUFDTCxDQUFDO0FBSkQsb0RBSUM7QUFFRDs7Ozs7R0FLRztBQUNILFNBQWdCLGtCQUFrQixDQUFDLFNBQTJDLEVBQUUsT0FBaUIsRUFBRSxNQUFpQjtJQUNoSCxJQUFJLE9BQU8sWUFBWSxpQkFBTyxJQUFJLG1FQUFxQyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQzlFLE9BQU8sQ0FBQyxzQkFBc0IsQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDbEQsTUFBTSxTQUFTLEdBQXlCLE9BQU8sQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUMvRCxJQUFJLFNBQVMsS0FBSyxTQUFTLEVBQUU7WUFDekIsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFO2dCQUMzQixTQUFTLENBQUMsYUFBYSxHQUFHLFNBQVMsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3BFLENBQUMsQ0FBQyxDQUFDO1NBQ047S0FDSjtJQUVELGtEQUFrRDtJQUNsRCxJQUFJLHNDQUFrQixDQUFDLE9BQU8sQ0FBQyxFQUFFO1FBQzdCLEtBQUssTUFBTSxLQUFLLElBQUksT0FBTyxDQUFDLFFBQVEsRUFBRTtZQUNsQyxrQkFBa0IsQ0FBQyxTQUFTLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1NBQ2hEO0tBQ0o7QUFDTCxDQUFDO0FBakJELGdEQWlCQztBQUVELFNBQVMsUUFBUSxDQUFDLE1BQWMsRUFBRSxTQUFtQjtJQUNqRCxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ1QsTUFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO0tBQ25EO0lBQ0QsS0FBSyxpQkFBTyxDQUFDLElBQUksQ0FBQztRQUNkLEdBQUcsRUFBRSxNQUFNO1FBQ1gsU0FBUztRQUNULFdBQVcsRUFBRSxJQUFJO0tBQ3BCLENBQUMsQ0FBQztBQUNQLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTkgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIikuXG4gKiBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBBIGNvcHkgb2YgdGhlIExpY2Vuc2UgaXMgbG9jYXRlZCBhdFxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBvciBpbiB0aGUgXCJsaWNlbnNlXCIgZmlsZSBhY2NvbXBhbnlpbmcgdGhpcyBmaWxlLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWRcbiAqIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmdcbiAqIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBSZXNwb25zZUJ1aWxkZXIgfSBmcm9tICdhc2stc2RrLWNvcmUnO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgc3lzdGVtUmVzb3VyY2UgfSBmcm9tICcuLi9jb21tb25Db250cm9scy9MYW5ndWFnZVN0cmluZ3MnO1xuaW1wb3J0IHsgQ29udHJvbCB9IGZyb20gJy4uL2NvbnRyb2xzL0NvbnRyb2wnO1xuaW1wb3J0IHsgaW1wbGVtZW50c0ludGVyYWN0aW9uTW9kZWxDb250cmlidXRvciB9IGZyb20gJy4uL2NvbnRyb2xzL21peGlucy9JbnRlcmFjdGlvbk1vZGVsQ29udHJpYnV0b3InO1xuaW1wb3J0IHsgQ29udHJvbEludGVyYWN0aW9uTW9kZWxHZW5lcmF0b3IsIGdlbmVyYXRlTW9kZWxEYXRhIH0gZnJvbSAnLi4vaW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRpb24vQ29udHJvbEludGVyYWN0aW9uTW9kZWxHZW5lcmF0b3InO1xuaW1wb3J0IHsgTW9kZWxEYXRhLCBNb2RlbERhdGFNYXAgfSBmcm9tICcuLi9pbnRlcmFjdGlvbk1vZGVsR2VuZXJhdGlvbi9Nb2RlbFR5cGVzJztcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2xvZ2dpbmcvTG9nZ2VyJztcbmltcG9ydCB7IENvbnRyb2xSZXNwb25zZUJ1aWxkZXIgfSBmcm9tICcuLi9yZXNwb25zZUdlbmVyYXRpb24vQ29udHJvbFJlc3BvbnNlQnVpbGRlcic7XG5pbXBvcnQgeyBTeXN0ZW1BY3QgfSBmcm9tICcuLi9zeXN0ZW1BY3RzL1N5c3RlbUFjdCc7XG5pbXBvcnQgeyBDb250cm9sSW5wdXQgfSBmcm9tICcuL0NvbnRyb2xJbnB1dCc7XG5pbXBvcnQgeyBDb250cm9sUmVzdWx0IH0gZnJvbSAnLi9Db250cm9sUmVzdWx0JztcbmltcG9ydCB7IGlzQ29udGFpbmVyQ29udHJvbCB9IGZyb20gJy4vaW50ZXJmYWNlcy9JQ29udGFpbmVyQ29udHJvbCc7XG5pbXBvcnQgeyBJQ29udHJvbCB9IGZyb20gJy4vaW50ZXJmYWNlcy9JQ29udHJvbCc7XG5pbXBvcnQgeyBJQ29udHJvbE1hbmFnZXIgfSBmcm9tICcuL2ludGVyZmFjZXMvSUNvbnRyb2xNYW5hZ2VyJztcbmltcG9ydCBpMThuZXh0IGZyb20gJ2kxOG5leHQnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGxpY2F0ZS1pbXBvcnRzXG5pbXBvcnQgeyBSZXNvdXJjZSB9IGZyb20gJ2kxOG5leHQnO1xuXG5jb25zdCBsb2cgPSBuZXcgTG9nZ2VyKCdBc2tTZGtDb250cm9sczpDb250cm9sTWFuYWdlcicpO1xuXG4vKipcbiAqIFByb3BlcnRpZXMgZm9yIGNyZWF0aW5nIGEgQ29udHJvbE1hbmFnZXIgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29udHJvbE1hbmFnZXJQcm9wcyB7XG4gICAgbG9jYWxlPzogc3RyaW5nLFxuICAgIGkxOG5PdmVycmlkZT86IFJlc291cmNlXG59XG5cbi8qKlxuICogRGVmaW5pbmcgdGhlIGhpZ2gtbGV2ZWwgZnVuY3Rpb25hbGl0eSBmb3IgYSBza2lsbCBidWlsdCB3aXRoIENvbnRyb2xzLlxuICpcbiAqIEVhY2ggc2tpbGwgc2hvdWxkIGRlZmluZSBhIGNvbmNyZXRlIHN1Yi1jbGFzcyB0aGF0IGltcGxlbWVudHMgYGNyZWF0ZUNvbnRyb2xUcmVlYCBhbmQgb3B0aW9uYWxseSBvdmVycmlkZSBvdGhlciBtZXRob2RzLlxuICpcbiAqIFN1bW1hcnk6XG4gKiAgKiBjcmVhdGVDb250cm9sVHJlZSgpIGNyZWF0ZXMgYSBoaWVyYXJjaHkgb2YgY29udHJvbHMgdGhhdCBjb29wZXJhdGl2ZWx5IG1hbmFnZSB0aGUgc2tpbGwgYmVoYXZpb3IuXG4gKiAgICogdGhlIG1ldGhvZHMgb24gdGhlIHJvb3QgY29udHJvbCB3aWxsIGJlIGNhbGxlZCB0byBwcm9jZXNzIHRoZSB1c2VyJ3MgaW5wdXQgYW5kIHRvIGdlbmVyYXRlIHN5c3RlbSBpbml0aWF0aXZlLlxuICogICAqIFRoZSBDb250cm9sIHRyZWUgZm9ybXMgdGhlIENvbnRyb2xsZXIgYW5kIHRoZSBNb2RlbCBvZiB0aGUgc2tpbGwuXG4gKlxuICogICogcmVuZGVyKCkgaXMgdGhlIGVudHJ5LXBvaW50IGZvciB0aGUgcmVuZGVyLXBoYXNlLCBha2EgdGhlIFZpZXcgbGF5ZXIuXG4gKiAgICogdHlwaWNhbGx5IHRoZSByZW5kZXIgbWV0aG9kIHdpbGwgZGVsZWdhdGUgdG8gQ29udHJvbHMgYW5kL29yIEFjdHMgZm9yIGZpbmUtZ3JhaW5lZCByZW5kZXJpbmcsIGJ1dCBpdCBpc1xuICogICAgIGxlZ2FsIHRvIGRvIHRoZSByZW5kZXJpbmcgYnkgYW55IG1lYW5zIHN1Y2ggYXMgYnkgY2FsbGluZyBvdXQgdG8gYSBuYXR1cmFsLWxhbmd1YWdlLWdlbmVyYXRpb24gYWxnb3JpdGhtIG9yIHNlcnZpY2UuXG4gKlxuICogICogYHJlbmRlcigpYCBidWlsZHMgdXAgdGhlIG91dHB1dCB1c2luZyBhIGBDb250cm9sUmVzcG9uc2VCdWlsZGVyYCB3aGljaCBpcyB1bHRpbWF0ZWx5IHVzZWQgdG8gYnVpbGQgYSByZWd1bGFyIEFsZXhhIFNESyBSZXNwb25zZSBvYmplY3RcbiAqXG4gKiAgKiBJbmZvcm1hdGlvbiBpcyBwYXNzZWQgYmV0d2VlbiB0aGUgQ29udHJvbGxlciBhbmQgdGhlIFZpZXcgaW4gdGhlIGZvcm0gb2YgYSBgQ29udHJvbFJlc3VsdGAuICBUaGUgYENvbnRyb2xSZXN1bHRgIGNvbXByaXNlc1xuICogICAgYSBsaXN0IG9mIFN5c3RlbUFjdHMgdGhhdCBkZXNjcmliZSAqd2hhdCogc2hvdWxkIGJlIGNvbW11bmljYXRlZCB0byB0aGUgdXNlciBidXQgZ2VuZXJhbGx5IHNob3VsZCBub3QgZGVzY3JpYmUgKmhvdyogdG8gcHJlc2VudCBpdC5cbiAqXG4gKiAgKiBgaGFuZGxlSW50ZXJuYWxFcnJvcmAgcHJvdmlkZXMgYW4gZW50cnktcG9pbnQgZm9yIGN1c3RvbSBoYW5kbGluZyBvZiBpbnRlcm5hbCBlcnJvcnMuXG4gKlxuICogICogYGJ1aWxkSW50ZXJhY3Rpb25Nb2RlbGAgcHJvdmlkZXMgYW4gZW50cnktcG9pbnQgZm9yIGJ1aWxkaW5nIHRoZSBDb250cm9sLXNwZWNpZmljIGFzcGVjdHMgb2Ygc2tpbGwncyBJbnRlcmFjdGlvbiBNb2RlbC5cbiAqXG4gKiBJbnRlcm5hdGlvbmFsaXphdGlvbiBhbmQgTG9jYWxpemF0aW9uXG4gKiAgKiBDb250cm9scyB0aGVtc2VsdmVzIGFyZSBsb2NhdGlvbi1hZ25vc3RpYy4gIFRoZXkgY29uc3VtZSBhYnN0cmFjdCBpbnB1dHMgKEludGVudHMsIGV0YykgYW5kIHByb2R1Y2UgYWJzdHJhY3Qgb3V0cHV0cyAoU3lzdGVtQWN0cylcbiAqXG4gKiAgKiBNYXBwaW5nIGxvY2FsaXplZCBpbnB1dCB0byBhYnN0cmFjdCBpbnB1dHMgaXMgdGhlIHJvbGUgb2YgTkxVIGFuZCB0aGUgbmVjZXNzYXJ5IGluZm9ybWF0aW9uIGlzIHN0b3JlZCBpbiB0aGUgSW50ZXJhY3Rpb24gTW9kZWxcbiAqICAgKiBUaGUgQ29udHJvbE1hbmFnZXIgcHJvcHMgaW5jbHVkZXMgYSBiYWcgb2YgbG9jYWxpemF0aW9uIGRhdGEgdGhhdCBpcyB1c2VkIGR1cmluZyBpbnRlcmFjdGlvbi1tb2RlbCBidWlsZGluZyBmb3IgYSBnaXZlbiBsb2NhbGVcbiAqICAgKiBUaGUgZnJhbWV3b3JrIHNoaXBzIHdpdGggYSBkZWZhdWx0IHNldCBvZiBpbnRlcmFjdGlvbiBtb2RlbCBkYXRhIGZvciBlbi1VU1xuICpcbiAqICAqIE1hcHBpbmcgYWJzdHJhY3Qgb3V0cHV0IHRvIHBoeXNpY2FsIG91dHB1dCAocHJvbXB0cywgQVBMIHN0cmluZ3MpIGV0YyBpcyB0aGUgcm9sZSBvZiB0aGUgcmVuZGVyaW5nIHBoYXNlLiAgVGhpcyBpbmZvcm1hdGlvbiBpc1xuICogICAgcGFydCBvZiB0aGUgc2tpbGwgZGVmaW5pdGlvbiBidXQgY2FuIGJlIGxvY2F0ZWQgaW4gdmFyaW91cyBwbGFjZXM6IGVpdGhlciBpbiBhIG1vbm9saXRoaWMgcmVuZGVyKCkgZnVuY3Rpb24sIG9yIHNjYXR0ZXJlZCBhcm91bmRcbiAqICAgIHRoZSBDb250cm9scyBhbmQgQWN0cyBpbiB0aGUgZm9ybSBvZiBwcm9wcy5cbiAqXG4gKiAgIFNlZSAvZG9jLy4uLiBmb3IgbW9yZSBpbmZvcm1hdGlvbiAgLy8gVE9ETzogdXBkYXRlIHdpdGggcHJlY2lzZSBsaW5rXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb250cm9sTWFuYWdlciBpbXBsZW1lbnRzIElDb250cm9sTWFuYWdlciB7XG5cbiAgICBwcm9wczogUmVxdWlyZWQ8Q29udHJvbE1hbmFnZXJQcm9wcz47XG5cbiAgICBzdGF0aWMgbWVyZ2VXaXRoRGVmYXVsdFByb3BzKHByb3BzOiBDb250cm9sTWFuYWdlclByb3BzIHwgdW5kZWZpbmVkKTogUmVxdWlyZWQ8Q29udHJvbE1hbmFnZXJQcm9wcz4ge1xuICAgICAgICBjb25zdCBkZWZhdWx0czogUmVxdWlyZWQ8Q29udHJvbE1hbmFnZXJQcm9wcz4gPSB7XG4gICAgICAgICAgICBsb2NhbGU6ICdlbi1VUycsXG4gICAgICAgICAgICBpMThuT3ZlcnJpZGU6IHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIF8ubWVyZ2VXaXRoKGRlZmF1bHRzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBhIENvbnRyb2wgTWFuYWdlci5cbiAgICAgKiBAcGFyYW0gcHJvcHNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcm9wcz86IENvbnRyb2xNYW5hZ2VyUHJvcHMpIHtcbiAgICAgICAgdGhpcy5wcm9wcyA9IENvbnRyb2xNYW5hZ2VyLm1lcmdlV2l0aERlZmF1bHRQcm9wcyhwcm9wcyk7XG4gICAgICAgIGNvbnN0IHJlc291cmNlOiBSZXNvdXJjZSA9IF8ubWVyZ2Uoc3lzdGVtUmVzb3VyY2UsIHRoaXMucHJvcHMuaTE4bk92ZXJyaWRlKTtcbiAgICAgICAgaTE4bkluaXQodGhpcy5wcm9wcy5sb2NhbGUsIHJlc291cmNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgdHJlZSBvZiBjb250cm9scyB0byBoYW5kbGUgc3RhdGUgbWFuYWdlbWVudCBhbmQgZGlhbG9nIGRlY2lzaW9ucyBmb3IgdGhlIHNraWxsLlxuICAgICAqXG4gICAgICogVXNhZ2Ugbm90ZXM6XG4gICAgICogQSBzaW5nbGUgY29udHJvbCBpcyBsZWdhbCBhbmQgd2lsbCBzdWZmaWNlIGZvciBzbWFsbCBza2lsbHMuIEZvciBsYXJnZXIgc2tpbGxzXG4gICAgICogYSB0cmVlIG9mIGNvbnRyb2xzIHN0cnVjdHVyZWQgdXNpbmcgQHNlZSBDb250YWluZXJDb250cm9sIHdpbGwgaGVscCBtYW5hZ2Ugc2tpbGwgY29tcGxleGl0eS5cbiAgICAgKlxuICAgICAqIEluIGFkdmFuY2VkIHNjZW5hcmlvcyB3aXRoIGR5bmFtaWMgY29udHJvbCB0cmVlIHNoYXBlcywgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG8gcHJvZHVjZSBhIHRyZWUgdGhhdCBpc1xuICAgICAqIGlkZW50aWNhbCB0byB0aGUgdHJlZSBhdCB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyB0dXJuLiAgVGhlIHNlcmlhbGl6YWJsZSBjb250cm9sIHN0YXRlIGNhbiBiZSBpbnNwZWN0ZWRcbiAgICAgKiBhcyBuZWNlc3NhcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VyaWFsaXphYmxlU3RhdGUgTWFwIG9mIGNvbnRyb2wgc3RhdGUgb2JqZWN0cyBrZXllZCBieSBgY29udHJvbElkYFxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIGlzIHByb3ZpZGVkIGZvciBhZHZhbmNlZCBjYXNlcyBpbiB3aGljaCB0aGUgdHJlZSBoYXMgYSBkeW5hbWljIHNoYXBlXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VkIG9uIHRoZSBhcHBsaWNhdGlvbiBzdGF0ZS5cbiAgICAgKiBAcmV0dXJuIEVpdGhlciBhIHNpbmdsZSBAc2VlIENvbnRyb2wgb3IgYSBAc2VlIENvbnRhaW5lckNvbnRyb2wgdGhhdCBpcyB0aGUgcm9vdCBvZiBhIHRyZWUuXG4gICAgICovXG4gICAgYWJzdHJhY3QgY3JlYXRlQ29udHJvbFRyZWUoc2VyaWFsaXphYmxlU3RhdGU6IHsgW2tleTogc3RyaW5nXTogYW55IH0pOiBDb250cm9sO1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5mb3JtYXRpb24gaW4gQ29udHJvbFJlc3VsdCBpbnRvIHVzZXItZmFjaW5nIGNvbnRlbnQgKHByb21wdHMgYW5kIEFQTCkuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0OiBUaGUgZGVmYXVsdCByZW5kZXJpbmcgc3RyYXRlZ3kgcmVuZGVycyBlYWNoIGBTeXN0ZW1BY3RgIGluIHR1cm4gYnkgY2FsbGluZyBgYWN0LmNvbnRyb2wucmVuZGVyKGFjdClgLlxuICAgICAqICAgICAgICAgIFRoaXMgc3RyYXRlZ3kgbGVhZHMgdG8gcHJvbXB0cyB0aGF0IGFyZSBhIGNvbmNhdGVuYXRpb24gb2YgdGhlIHByb21wdC1mcmFnbWVudCBmb3IgZWFjaCBgU3lzdGVtQWN0YC5cbiAgICAgKlxuICAgICAqIFVzYWdlOlxuICAgICAqICAqIEluIG1hbnkgc2l0dWF0aW9ucyByZW5kZXJpbmcgdGhlIGFjdHMgb25lLWJ5LW9uZSBpcyBzdWZmaWNpZW50IGFzIHRoZSBjb25jYXRlbmF0aW9uIG9mIHByb21wdCBmcmFnbWVudHNcbiAgICAgKiAgICBsZWFkcyB0byB1c2FibGUgcHJvbXB0cy4gIEZvciBleGFtcGxlIFtWYWx1ZVNldEFjdChhZ2VDdHJsLCA1KSwgUmVxdWVzdFZhbHVlQWN0KG5hbWVDdHJsKV0gLT4gJ09LLCA1LiBXaGF0IGlzIHlvdXIgbmFtZT9cIlxuICAgICAqXG4gICAgICogICogRm9yIG1vcmUgY29tcGxleCBzaXR1YXRpb25zLCBvdmVycmlkZSB0aGlzIG1ldGhvZCBhbmQgaW1wbGVtZW50IGEgY3VzdG9tIHJlbmRlcmluZyBzdHJhdGVneS4gIE9mdGVuIHRoZSBzb2x1dGlvbiB3aWxsXG4gICAgICogICAgYmUgdG8gaW1wbGVtZW50IHNvbWUgc3BlY2lhbCBjYXNlcyBhbmQgb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIHRoZSBkZWZhdWx0IGJ5IGNhbGxpbmcgc3VwZXIucmVuZGVyKCkgb3IgYnkgZGlyZWN0bHkgY2FsbGluZ1xuICAgICAqICAgIGBDb250cm9sTWFuYWdlci5yZW5kZXJBY3RzT25lQnlPbmUoKWAuXG4gICAgICpcbiAgICAgKi9cbiAgICByZW5kZXIocmVzdWx0OiBDb250cm9sUmVzdWx0LCBpbnB1dDogQ29udHJvbElucHV0LCBjb250cm9sUmVzcG9uc2VCdWlsZGVyOiBDb250cm9sUmVzcG9uc2VCdWlsZGVyKTogdm9pZCB8IFByb21pc2U8dm9pZD4ge1xuICAgICAgICByZW5kZXJBY3RzSW5TZXF1ZW5jZShyZXN1bHQuYWN0cywgaW5wdXQsIGNvbnRyb2xSZXNwb25zZUJ1aWxkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBhbiBpbnRlcm5hbCBlcnJvci5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgb25seSBmb3IgbG9nZ2luZywgcmVwb3J0aW5nIGFuZCBwZXJoYXBzIG1lbnRpb25pbmcgdGhlIHNpdHVhdGlvbiB0byB0aGUgdXNlci5cbiAgICAgKiBUaGUgdXNlciBzZXNzaW9uIHdpbGwgYmUgY2xvc2VkLlxuICAgICAqXG4gICAgICogRGVmYXVsdDogVGhlIGVycm9yIG9iamVjdCBpcyBjb252ZXJ0ZWQgaW50byBhbiBvYmplY3Qgd2l0aCBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYW5kIGxvZ2dlZCBhdCBsb2dMZXZlbD1lcnJvclxuICAgICAqIEBwYXJhbSBpbnB1dFxuICAgICAqIEBwYXJhbSBlcnJvclxuICAgICAqIEBwYXJhbSByZXNwb25zZUJ1aWxkZXJcbiAgICAgKi9cbiAgICBoYW5kbGVJbnRlcm5hbEVycm9yKGlucHV0OiBDb250cm9sSW5wdXQsIGVycm9yOiBhbnksIHJlc3BvbnNlQnVpbGRlcjogUmVzcG9uc2VCdWlsZGVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGVyciA9IGVycm9yLnN0YWNrICE9PSB1bmRlZmluZWQgPyB7IG5hbWU6IGVycm9yLm5hbWUsIG1zZzogZXJyb3IubWVzc2FnZSwgc3RhY2s6IGVycm9yLnN0YWNrIH0gOiBlcnJvcjsgLy8gRXJyb3IgZG9lc24ndCBoYXZlIGVudW1lcmFibGUgcHJvcGVydGllcywgc28gd2UgY29udmVydCBpdC5cbiAgICAgICAgbG9nLmVycm9yKGBFcnJvciBoYW5kbGVkOiAke0pTT04uc3RyaW5naWZ5KGVycil9YCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGludGVyYWN0aW9uIG1vZGVsIGNvbnRlbnQgZm9yIHRoZSBDb250cm9sIFRyZWVcbiAgICAgKlxuICAgICAqIFVzYWdlOlxuICAgICAqICogVGhlIGltRGF0YU1hcCBoYXMgJ2VuLVVTJyBtb2RlbERhdGEgcmVnaXN0ZXJlZCBieSBkZWZhdWx0XG4gICAgICogKiBUaGUgZGV2ZWxvcGVyIG1heSBjb25maWd1cmUgYW5kIHJlZ2lzdGVyIGFkZGl0aW9uYWwgYGltRGF0YU1hcGAgaW5zdGFuY2VzIHRvIHN1cHBvcnQgYWRkaXRpb25hbCBsb2NhbGVzXG4gICAgICpcbiAgICAgKiAqIElmIGltRGF0YU1hcCBkb2Vzbid0IGhhdmUgZGF0YSBmb3IgdGhlIHJlcXVlc3RlZCBsb2NhbGUgYSBgTG9jYWxlTm90U3VwcG9ydGVkRXJyb3JgIHdpbGwgYmUgdGhyb3duXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZ2VuZXJhdG9yIEludGVyYWN0aW9uIE1vZGVsIEdlbmVyYXRvclxuICAgICAqIEBwYXJhbSBsb2NhbGUgVGhlIGxvY2FsZSBjb2RlLCBFLkcuICdlbi1VUycsICdkZS1ERScsICdqYS1KUCcuIFJFRjogaHR0cHM6Ly9kZXZlbG9wZXIuYW1hem9uLmNvbS9lbi1VUy9kb2NzL2FsZXhhL2N1c3RvbS1za2lsbHMvZGV2ZWxvcC1za2lsbHMtaW4tbXVsdGlwbGUtbGFuZ3VhZ2VzLmh0bWwjaDItY29kZS1jaGFuZ2VzXG4gICAgICovXG4gICAgYnVpbGRJbnRlcmFjdGlvbk1vZGVsKGdlbmVyYXRvcjogQ29udHJvbEludGVyYWN0aW9uTW9kZWxHZW5lcmF0b3IpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgcm9vdENvbnRyb2wgPSB0aGlzLmNyZWF0ZUNvbnRyb2xUcmVlKHt9KTtcbiAgICAgICAgY29uc3QgaW1EYXRhOiBNb2RlbERhdGEgPSBnZW5lcmF0ZU1vZGVsRGF0YSgpO1xuICAgICAgICB1cGRhdGVJTUZvckNvbnRyb2woZ2VuZXJhdG9yLCByb290Q29udHJvbCwgaW1EYXRhKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVuZGVyIGVhY2ggb2YgdGhlIGFjdHMsIG9uZS1ieS1vbmUuXG4gKlxuICpcbiAqIEBwYXJhbSBzeXN0ZW1BY3RzIFRoZSBzeXN0ZW0gYWN0cyB0byByZW5kZXJcbiAqIEBwYXJhbSBjb250ZXh0XG4gKiBAcGFyYW0gcmVzcG9uc2VCdWlsZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJBY3RzSW5TZXF1ZW5jZShzeXN0ZW1BY3RzOiBTeXN0ZW1BY3RbXSwgaW5wdXQ6IENvbnRyb2xJbnB1dCwgY29udHJvbFJlc3BvbnNlQnVpbGRlcjogQ29udHJvbFJlc3BvbnNlQnVpbGRlcik6IHZvaWQge1xuICAgIGZvciAoY29uc3QgYWN0IG9mIHN5c3RlbUFjdHMpIHtcbiAgICAgICAgYWN0LmNvbnRyb2wucmVuZGVyQWN0KGFjdCwgaW5wdXQsIGNvbnRyb2xSZXNwb25zZUJ1aWxkZXIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHbyB0aHJvdWdoIHRoZSBlbnRpcmUgY29udHJvbCB0cmVlIGFuZCB1cGRhdGUgSU1cbiAqIEBwYXJhbSBnZW5lcmF0b3JcbiAqIEBwYXJhbSBjb250cm9sXG4gKiBAcGFyYW0gbG9jYWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVJTUZvckNvbnRyb2woZ2VuZXJhdG9yOiBDb250cm9sSW50ZXJhY3Rpb25Nb2RlbEdlbmVyYXRvciwgY29udHJvbDogSUNvbnRyb2wsIGltRGF0YTogTW9kZWxEYXRhKTogdm9pZCB7XG4gICAgaWYgKGNvbnRyb2wgaW5zdGFuY2VvZiBDb250cm9sICYmIGltcGxlbWVudHNJbnRlcmFjdGlvbk1vZGVsQ29udHJpYnV0b3IoY29udHJvbCkpIHtcbiAgICAgICAgY29udHJvbC51cGRhdGVJbnRlcmFjdGlvbk1vZGVsKGdlbmVyYXRvciwgaW1EYXRhKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SWRzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZCA9IGNvbnRyb2wuZ2V0VGFyZ2V0SWRzKCk7XG4gICAgICAgIGlmICh0YXJnZXRJZHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFyZ2V0SWRzLmZvckVhY2goKHRhcmdldElkKSA9PiB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yLnRhcmdldFNsb3RJZHMgPSBnZW5lcmF0b3IudGFyZ2V0U2xvdElkcy5hZGQodGFyZ2V0SWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBjb250YWluZXIgY29udHJvbCwgZG8gc2FtZSB0aGluZyByZWN1cnNpdmVseVxuICAgIGlmIChpc0NvbnRhaW5lckNvbnRyb2woY29udHJvbCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjb250cm9sLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICB1cGRhdGVJTUZvckNvbnRyb2woZ2VuZXJhdG9yLCBjaGlsZCwgaW1EYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaTE4bkluaXQobG9jYWxlOiBzdHJpbmcsIHJlc291cmNlczogUmVzb3VyY2UpOiB2b2lkIHtcbiAgICBpZiAoIWxvY2FsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzcGVjaWZ5IHRoZSBsYW5ndWFnZS4nKTtcbiAgICB9XG4gICAgdm9pZCBpMThuZXh0LmluaXQoe1xuICAgICAgICBsbmc6IGxvY2FsZSxcbiAgICAgICAgcmVzb3VyY2VzLFxuICAgICAgICBmYWxsYmFja0xuZzogJ2VuJyxcbiAgICB9KTtcbn1cbiJdfQ==