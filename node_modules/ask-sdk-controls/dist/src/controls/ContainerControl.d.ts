import { Control, ControlProps, ControlState } from './Control';
import { ControlInput } from './ControlInput';
import { ControlResultBuilder } from './ControlResult';
import { IContainerControl } from './interfaces/IContainerControl';
/**
 * Record tracking the turn that a child did something
 */
interface ChildActivityRecord {
    controlId: string;
    turnNumber: number;
}
/**
 * Container state for use in arbitration
 */
export declare class ContainerControlState implements ControlState {
    value?: any;
    lastHandlingControl?: ChildActivityRecord;
    lastInitiativeChild?: ChildActivityRecord;
}
export declare class ContainerControlProps implements ControlProps {
    id: string;
}
export declare class ContainerControlCompleteProps implements ControlProps {
    id: string;
}
/**
 *  Basic container for managing a set of child controls
 *
 *  The basic container does not handle inputs or takes initiative itself but sub-classes
 *  of `ContainerControl` can and should add high-level behaviors and respond to high-level intents.
 *
 *  Container controls should forward simple inputs to the child controls whenever possible in order
 *  to share the load and achieve scalable logic.
 *
 *  Container controls should explicitly decide which child will handle an input or take the initiative
 *  in situations where there are multiple children that respond `canHandle = true` or `canTakeInitiative = true`.
 *
 *  The default decision logic in decideHandlingChild / decideInitiativeChild:
 *   1. Choose the most-recent initiative control if is a candidate.
 *   2. Otherwise, choose the first candidate in the positional order of the `this.children` array.
 *   3. In the special case of input===FallbackIntent, only the most-recent initiative control is considered.
 *      If it is not a candidate, then no child is selected.
 *
 *  Usage:
 *   * Use a ContainerControl to organize and manage a set of child controls.
 *   * Typically a sub-class of ContainerControl is most useful as it allows for customization
 *     of logic before and after delegating to the children.  A sub-class can also customize the
 *     decision logic when multiple children are competing to handle an input or take the initiative.
 */
export declare class ContainerControl extends Control implements IContainerControl {
    children: Control[];
    state: ContainerControlState;
    rawProps: ContainerControlProps;
    props: ContainerControlCompleteProps;
    selectedHandlingChild: Control | undefined;
    selectedInitiativeChild: Control | undefined;
    constructor(props: ContainerControlProps);
    static mergeWithDefaultProps(props: ContainerControlProps): any;
    /**
     *
     * @param control
     * @returns the container
     */
    addChild(control: Control): this;
    canHandle(input: ControlInput): Promise<boolean>;
    /**
     * Handle the request
     */
    handle(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    canTakeInitiative(input: ControlInput): Promise<boolean>;
    takeInitiative(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    stringifyStateForDiagram(): string;
    canHandleByChild(input: ControlInput): Promise<boolean>;
    handleByChild(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    gatherHandlingCandidates(input: ControlInput): Promise<Control[]>;
    /**
     * Decide a winner (or none at all) from the canHandle candidates
     *
     * The eligible candidates are child controls for which `canHandle(input) = true`
     *
     * Default: The default candidate-selection logic is:
     *  1. Choose the  most-recent initiative control if is a candidate.
     *  2. Otherwise, choose the first candidate in the positional order of the `this.children` array.
     *  3. In the special case of input===FallbackIntent, only the most-recent initiative control is considered.
     *     If it is not a candidate, then no child is selected and this method returns undefined.
     *
     * Remarks:
     *  * The special case for FallbackIntent exists because that intent is not user-initiative -- rather it indicates
     *    a failure to understanding the user.  In cases of misunderstanding, only active controls should be considered.
     *
     * @param container
     * @param candidates
     * @param input
     */
    decideHandlingChild(candidates: Control[], input: ControlInput): Promise<Control | undefined>;
    canTakeInitiativeByChild(input: ControlInput): Promise<boolean>;
    takeInitiativeByChild(input: ControlInput, resultBuilder: ControlResultBuilder): Promise<void>;
    gatherInitiativeCandidates(input: ControlInput): Promise<Control[]>;
    /**
     * Decide a winner (or none at all) from the canTakeInitiative candidates
     *
     * The eligible candidates are child controls for which `canTakeInitiative(input) = true`
     *
     * Default: The default candidate-selection logic is:
     *  1. choose the most-recent initiative control if is a candidate.
     *  2. otherwise choose the first candidate in the positional order of the `this.children` array.
     *
     * @param container
     * @param candidates
     * @param input
     */
    decideInitiativeChild(candidates: Control[], input: ControlInput): Promise<Control | undefined>;
}
export declare function tryGetForId(options: Control[], childId?: string): Control | undefined;
export {};
//# sourceMappingURL=ContainerControl.d.ts.map