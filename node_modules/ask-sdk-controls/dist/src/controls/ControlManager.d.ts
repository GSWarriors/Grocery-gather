import { ResponseBuilder } from 'ask-sdk-core';
import { Control } from '../controls/Control';
import { ControlInteractionModelGenerator } from '../interactionModelGeneration/ControlInteractionModelGenerator';
import { ModelData } from '../interactionModelGeneration/ModelTypes';
import { ControlResponseBuilder } from '../responseGeneration/ControlResponseBuilder';
import { SystemAct } from '../systemActs/SystemAct';
import { ControlInput } from './ControlInput';
import { ControlResult } from './ControlResult';
import { IControl } from './interfaces/IControl';
import { IControlManager } from './interfaces/IControlManager';
import { Resource } from 'i18next';
/**
 * Properties for creating a ControlManager instance.
 */
export interface ControlManagerProps {
    locale?: string;
    i18nOverride?: Resource;
}
/**
 * Defining the high-level functionality for a skill built with Controls.
 *
 * Each skill should define a concrete sub-class that implements `createControlTree` and optionally override other methods.
 *
 * Summary:
 *  * createControlTree() creates a hierarchy of controls that cooperatively manage the skill behavior.
 *   * the methods on the root control will be called to process the user's input and to generate system initiative.
 *   * The Control tree forms the Controller and the Model of the skill.
 *
 *  * render() is the entry-point for the render-phase, aka the View layer.
 *   * typically the render method will delegate to Controls and/or Acts for fine-grained rendering, but it is
 *     legal to do the rendering by any means such as by calling out to a natural-language-generation algorithm or service.
 *
 *  * `render()` builds up the output using a `ControlResponseBuilder` which is ultimately used to build a regular Alexa SDK Response object
 *
 *  * Information is passed between the Controller and the View in the form of a `ControlResult`.  The `ControlResult` comprises
 *    a list of SystemActs that describe *what* should be communicated to the user but generally should not describe *how* to present it.
 *
 *  * `handleInternalError` provides an entry-point for custom handling of internal errors.
 *
 *  * `buildInteractionModel` provides an entry-point for building the Control-specific aspects of skill's Interaction Model.
 *
 * Internationalization and Localization
 *  * Controls themselves are location-agnostic.  They consume abstract inputs (Intents, etc) and produce abstract outputs (SystemActs)
 *
 *  * Mapping localized input to abstract inputs is the role of NLU and the necessary information is stored in the Interaction Model
 *   * The ControlManager props includes a bag of localization data that is used during interaction-model building for a given locale
 *   * The framework ships with a default set of interaction model data for en-US
 *
 *  * Mapping abstract output to physical output (prompts, APL strings) etc is the role of the rendering phase.  This information is
 *    part of the skill definition but can be located in various places: either in a monolithic render() function, or scattered around
 *    the Controls and Acts in the form of props.
 *
 *   See /doc/... for more information  // TODO: update with precise link
 */
export declare abstract class ControlManager implements IControlManager {
    props: Required<ControlManagerProps>;
    static mergeWithDefaultProps(props: ControlManagerProps | undefined): Required<ControlManagerProps>;
    /**
     * Creates an instance of a Control Manager.
     * @param props
     */
    constructor(props?: ControlManagerProps);
    /**
     * Creates the tree of controls to handle state management and dialog decisions for the skill.
     *
     * Usage notes:
     * A single control is legal and will suffice for small skills. For larger skills
     * a tree of controls structured using @see ContainerControl will help manage skill complexity.
     *
     * In advanced scenarios with dynamic control tree shapes, this method is expected to produce a tree that is
     * identical to the tree at the end of the previous turn.  The serializable control state can be inspected
     * as necessary.
     *
     * @param serializableState Map of control state objects keyed by `controlId`
     *                          This is provided for advanced cases in which the tree has a dynamic shape
     *                          based on the application state.
     * @return Either a single @see Control or a @see ContainerControl that is the root of a tree.
     */
    abstract createControlTree(serializableState: {
        [key: string]: any;
    }): Control;
    /**
     * Transforms the information in ControlResult into user-facing content (prompts and APL).
     *
     * Default: The default rendering strategy renders each `SystemAct` in turn by calling `act.control.render(act)`.
     *          This strategy leads to prompts that are a concatenation of the prompt-fragment for each `SystemAct`.
     *
     * Usage:
     *  * In many situations rendering the acts one-by-one is sufficient as the concatenation of prompt fragments
     *    leads to usable prompts.  For example [ValueSetAct(ageCtrl, 5), RequestValueAct(nameCtrl)] -> 'OK, 5. What is your name?"
     *
     *  * For more complex situations, override this method and implement a custom rendering strategy.  Often the solution will
     *    be to implement some special cases and otherwise fallback to the default by calling super.render() or by directly calling
     *    `ControlManager.renderActsOneByOne()`.
     *
     */
    render(result: ControlResult, input: ControlInput, controlResponseBuilder: ControlResponseBuilder): void | Promise<void>;
    /**
     * Handle an internal error.
     *
     * This is only for logging, reporting and perhaps mentioning the situation to the user.
     * The user session will be closed.
     *
     * Default: The error object is converted into an object with enumerable properties and logged at logLevel=error
     * @param input
     * @param error
     * @param responseBuilder
     */
    handleInternalError(input: ControlInput, error: any, responseBuilder: ResponseBuilder): void;
    /**
     * Builds interaction model content for the Control Tree
     *
     * Usage:
     * * The imDataMap has 'en-US' modelData registered by default
     * * The developer may configure and register additional `imDataMap` instances to support additional locales
     *
     * * If imDataMap doesn't have data for the requested locale a `LocaleNotSupportedError` will be thrown
     *
     * @param generator Interaction Model Generator
     * @param locale The locale code, E.G. 'en-US', 'de-DE', 'ja-JP'. REF: https://developer.amazon.com/en-US/docs/alexa/custom-skills/develop-skills-in-multiple-languages.html#h2-code-changes
     */
    buildInteractionModel(generator: ControlInteractionModelGenerator): void;
}
/**
 * Render each of the acts, one-by-one.
 *
 *
 * @param systemActs The system acts to render
 * @param context
 * @param responseBuilder
 */
export declare function renderActsInSequence(systemActs: SystemAct[], input: ControlInput, controlResponseBuilder: ControlResponseBuilder): void;
/**
 * Go through the entire control tree and update IM
 * @param generator
 * @param control
 * @param locale
 */
export declare function updateIMForControl(generator: ControlInteractionModelGenerator, control: IControl, imData: ModelData): void;
//# sourceMappingURL=ControlManager.d.ts.map