"use strict";
/*
 * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractStateCore = exports.extractStateFromControlTree = exports.attachStateToControlTree = exports.ControlHandler = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const ControlInput_1 = require("../controls/ControlInput");
const ControlResult_1 = require("../controls/ControlResult");
const IContainerControl_1 = require("../controls/interfaces/IContainerControl");
const Logger_1 = require("../logging/Logger");
const ControlResponseBuilder_1 = require("../responseGeneration/ControlResponseBuilder");
const ControlTreeVisualization_1 = require("../utils/ControlTreeVisualization");
const ControlVisitor_1 = require("../utils/ControlVisitor");
const RequestUtils_1 = require("../utils/RequestUtils");
const SerializationValidator_1 = require("../utils/SerializationValidator");
const SessionBehavior_1 = require("./SessionBehavior");
const log = new Logger_1.Logger('AskSdkControls:ControlHandler');
/**
 * Session context information in addition to that provided by Alexa Service.
 */
class AdditionalSessionContext {
    constructor() {
        this.turnNumber = 0;
    }
}
class ControlHandler {
    /**
     *
     *
     * @param controlManager ControlManager
     */
    constructor(controlManager) {
        /**
         * Determines if the controls state will be correctly reestablished on the next turn
         *
         * Usage:
         *  * If a skill uses more than one ControlHandler, the state validation procedure gets
         *    confused due to unexpected control states in session attributes. In this situation,
         *    set `validateStateRoundtrip = false`.
         *
         * @memberof ControlHandler
         */
        this.validateStateRoundtrip = true; // TODO improve the validation testing and remove this
        this.controlManager = controlManager;
    }
    prepare(handlerInput) {
        if (this.preparedRequestId === handlerInput.requestEnvelope.request.requestId) {
            return; // don't prepare again for the same requestId.
        }
        this.preparedRequestId = handlerInput.requestEnvelope.request.requestId;
        // retrieve and update the context object.
        const retrievedContext = handlerInput.attributesManager.getSessionAttributes()[ControlHandler.attributeNameContext];
        this.additionalSessionContext = retrievedContext !== undefined ? JSON.parse(retrievedContext) : new AdditionalSessionContext();
        this.additionalSessionContext.turnNumber += 1;
        // retrieve the control state
        const stateMap = this.getStateMapFromSessionAttributes(handlerInput);
        // build the control tree and attach state
        this.rootControl = this.controlManager.createControlTree(stateMap);
        attachStateToControlTree(this.rootControl, stateMap);
        // create the input object for use in the main processing.
        const controls = ControlHandler.createControlMap(this.rootControl, {});
        this.controlInput = new ControlInput_1.ControlInput(handlerInput, this.additionalSessionContext.turnNumber, controls);
    }
    getStateMapFromSessionAttributes(handlerInput) {
        const retrievedStateJSON = handlerInput.attributesManager.getSessionAttributes()[ControlHandler.attributeNameState];
        const stateMap = retrievedStateJSON !== undefined ? JSON.parse(retrievedStateJSON) : {};
        return stateMap;
    }
    static createControlMap(control, mapAcc) {
        mapAcc[control.id] = control;
        if (IContainerControl_1.isContainerControl(control)) {
            for (const child of control.children) {
                ControlHandler.createControlMap(child, mapAcc);
            }
        }
        return mapAcc; // returning the accumulator allows the call-site to be more readable
    }
    async canHandle(handlerInput) {
        try {
            this.prepare(handlerInput);
            return this.rootControl.canHandle(this.controlInput);
        }
        catch (error) {
            if (this.controlManager.handleInternalError) {
                this.controlManager.handleInternalError(this.controlInput, error, handlerInput.responseBuilder);
            }
            throw error; // rethrow so top-level observes it too.
        }
    }
    async handle(handlerInput, processInput = true) {
        try {
            this.prepare(handlerInput);
            /*
             * Process the turn through the application.
             * Do the work (state updates and dialog policy)
             */
            const responseBuilder = new ControlResponseBuilder_1.ControlResponseBuilder(handlerInput.responseBuilder);
            const resultBuilder = new ControlResult_1.ControlResultBuilder();
            await ControlHandler.handleCore(this.rootControl, this.controlInput, resultBuilder, processInput);
            // Compose the response
            const response = await this.buildResponseCore(resultBuilder.build(), responseBuilder, this.controlInput);
            // Collate the Control state objects for serialization
            /* Note: we merge onto the prevailing state for the edge-case of multiple ControlHandlers in the skill that are active on different turns.
             *       merging avoid one controlHandler stomping on the state of the other.  Context is currently OK/good to be stomped on.
             */
            const priorStateMap = this.getStateMapFromSessionAttributes(handlerInput);
            const currentStateMap = this.getSerializableControlStates();
            const mergedStateMap = Object.assign(Object.assign({}, priorStateMap), currentStateMap);
            const stateToSaveJson = JSON.stringify(mergedStateMap, null, 2);
            log.info(`Saving state...\n${stateToSaveJson} `);
            const contextToSaveJson = JSON.stringify(this.additionalSessionContext, null, 2);
            log.info(`Saving context...\n${contextToSaveJson}`);
            this.controlInput.handlerInput.attributesManager.getSessionAttributes()[ControlHandler.attributeNameState] = stateToSaveJson;
            this.controlInput.handlerInput.attributesManager.getSessionAttributes()[ControlHandler.attributeNameContext] = contextToSaveJson;
            // Check that the serialized state will survive the round trip
            if (this.validateStateRoundtrip) {
                SerializationValidator_1.validateSerializedState(stateToSaveJson, this.controlManager, this.controlInput);
            }
            return response;
        }
        catch (error) {
            if (this.controlManager.handleInternalError) {
                this.controlManager.handleInternalError(this.controlInput, error, handlerInput.responseBuilder);
            }
            return Object.assign(Object.assign({}, handlerInput.responseBuilder.getResponse()), { isTurnEnding: true });
        }
    }
    /**
     * Creates a string 'C:<nControls>' for inclusion in UserAgent to indicate usage.
     *
     * The information gathered is only the number of Controls being used.
     * This will help the dev team to understand usage - thank you!
     */
    userAgentInfo() {
        var _a;
        const rootControl = (_a = this.rootControl) !== null && _a !== void 0 ? _a : this.controlManager.createControlTree({});
        let nControls = 0;
        ControlVisitor_1.visitControls(rootControl, () => { nControls++; });
        return `nCtrl:${nControls}`;
    }
    /**
     * Implements the core of processing, which  is handle(request) -> HandleResult + state updates
     * Public for testing.
     * @param request
     * @param context
     *
     * @param handleInput whether to handle the input. if false, processing skips to the initiative phase.
     *
     * returns [controlResult, shouldEndSession]
     */
    static async handleCore(rootControl, input, resultBuilder, handleInput = true) {
        log.info("-------------------------------------------------------------------------------------------------");
        log.info(`Turn ${input.turnNumber} started`);
        log.info(`Input: ${RequestUtils_1.requestToString(input.handlerInput.requestEnvelope.request)}`);
        log.info(`UI at start: \n${ControlTreeVisualization_1.generateControlTreeTextDiagram(rootControl, input.turnNumber)}`);
        if (handleInput) {
            const canHandleResponse = await rootControl.canHandle(input);
            if (!canHandleResponse) {
                log.warn(" *WARN* rootControl returned canHandle=false.  Closing session");
                log.info(`UI at end of turn: \n${ControlTreeVisualization_1.generateControlTreeTextDiagram(rootControl, input.turnNumber)}`);
                return;
            }
            // HANDLE
            await rootControl.handle(input, resultBuilder);
        }
        // Optional INITIATIVE PHASE
        if (!resultBuilder.hasInitiativeAct() && resultBuilder.sessionBehavior === SessionBehavior_1.SessionBehavior.OPEN) {
            await ControlHandler.initiativePhase(rootControl, input, resultBuilder);
        }
        // TODO: track the specific controlID that generated the initiative. make it available so that controls
        // can use a hasInitiative() predicate and reason about whether they are actively running the conversation.
        log.info(`HandleResponse: ${resultBuilder}`);
        log.info(`UI at end of turn: \n${ControlTreeVisualization_1.generateControlTreeTextDiagram(rootControl, input.turnNumber)}`);
    }
    static async initiativePhase(rootControl, input, resultBuilder) {
        log.debug(`UI at start of initiative phase: \n${ControlTreeVisualization_1.generateControlTreeTextDiagram(rootControl, input.turnNumber)}`);
        const canTakeInitiative = await rootControl.canTakeInitiative(input);
        if (canTakeInitiative) {
            await rootControl.takeInitiative(input, resultBuilder);
            if (!resultBuilder.hasInitiativeAct()) {
                throw new Error("Something responded with `canTakeInitiative=true` but no initiative item was produced.");
            }
        }
        else {
            log.debug("End of handle: nothing wanted to take initiative.");
        }
        return;
    }
    /**
     * Take the initiative in the dialog.
     *
     * Any existing content in the Response's prompt & reprompt is overwritten. To avoid losing this content, pass it
     * in using parameters promptPrefix & repromptPrefix.
     *
     * Usage:
     *  * This method is typically used to transition from a regular RequestHandler into Controls
     *    For example, when a regular RequestHandler consumes the input but doesn't want to keep the initiative, it can ask
     *    a ControlHandler to take the initiative to complete the turn.
     *
     * @param handlerInput
     * @param promptPrefix
     * @param repromptPrefix
     */
    async takeInitiative(handlerInput, promptPrefix, repromptPrefix) {
        if (repromptPrefix === undefined) {
            repromptPrefix = promptPrefix;
        }
        /* NOTE: we call handle(.., false) rather than directly calling initiativePhase() as we need all
         * the usual turn book-keeping (prepare, logging, state loading & saving) to occur
         */
        const response = await this.handle(handlerInput, false);
        const [prompt, reprompt] = ControlHandler.getPromptAndRepromptFromResponse(response);
        if (response.outputSpeech === undefined) {
            response.outputSpeech = { type: 'PlainText', text: promptPrefix };
        }
        else if (response.outputSpeech.type === 'SSML') {
            response.outputSpeech = { type: 'SSML', ssml: prompt.replace('<speak>', `<speak>${promptPrefix}`) };
        }
        else {
            response.outputSpeech = { type: 'PlainText', text: promptPrefix + prompt };
        }
        if (response.reprompt === undefined) {
            response.reprompt = { outputSpeech: { type: 'PlainText', text: repromptPrefix } };
        }
        else if (response.reprompt.outputSpeech.type === 'SSML') {
            response.reprompt.outputSpeech = { type: 'SSML', ssml: reprompt.replace('<speak>', `<speak>${repromptPrefix}`) };
        }
        else {
            response.reprompt.outputSpeech = { type: 'PlainText', text: repromptPrefix + reprompt };
        }
        return response;
    }
    static getPromptAndRepromptFromResponse(response) {
        const prompt = response.outputSpeech === undefined
            ? ''
            : (response.outputSpeech.type === 'SSML')
                ? response.outputSpeech.ssml.replace('<ssml>', '').replace('</ssml>', '')
                : response.outputSpeech.text;
        const reprompt = response.reprompt === undefined
            ? ''
            : (response.reprompt.outputSpeech.type === 'SSML')
                ? response.reprompt.outputSpeech.ssml.replace('<ssml>', '').replace('</ssml>', '')
                : response.reprompt.outputSpeech.text;
        return [prompt, reprompt];
    }
    async buildResponseCore(result, controlResponseBuilder, input) {
        await this.controlManager.render(result, input, controlResponseBuilder);
        const response = controlResponseBuilder.getResponse();
        switch (result.sessionBehavior) {
            case SessionBehavior_1.SessionBehavior.OPEN:
                response.shouldEndSession = false;
                break;
            case SessionBehavior_1.SessionBehavior.END:
                response.shouldEndSession = true;
                break;
            case SessionBehavior_1.SessionBehavior.IDLE:
                response.shouldEndSession = undefined;
                break;
            default: throw new Error(`unknown SessionBehavior value: ${JSON.stringify(result)}`);
        }
        return Object.assign(Object.assign({}, response), { isTurnEnding: result.hasInitiativeAct() });
    }
    getSerializableControlStates() {
        return extractStateFromControlTree(this.rootControl);
    }
}
exports.ControlHandler = ControlHandler;
ControlHandler.attributeNameState = "__controlState";
ControlHandler.attributeNameContext = "__controlContext";
/**
 * Visits each control in the tree and attaches the corresponding state object
 *
 * @param rootControl root
 * @param state
 */
function attachStateToControlTree(rootControl, state) {
    if (state === undefined) {
        return;
    }
    const myState = state[rootControl.id];
    if (myState !== undefined) {
        rootControl.setSerializableState(myState);
    }
    if (IContainerControl_1.isContainerControl(rootControl)) {
        for (const child of rootControl.children) {
            attachStateToControlTree(child, state);
        }
    }
}
exports.attachStateToControlTree = attachStateToControlTree;
/**
 * Visits each controls and collates the state objects.
 *
 * @param rootControl
 * @param priorState
 */
function extractStateFromControlTree(rootControl) {
    const stateObj = {};
    extractStateCore(rootControl, stateObj);
    return stateObj;
}
exports.extractStateFromControlTree = extractStateFromControlTree;
function extractStateCore(control, state) {
    if (lodash_1.default.has(state, control.id)) {
        throw new Error(`Duplicate control id: ${control.id}`);
    }
    state[control.id] = control.getSerializableState();
    if (IContainerControl_1.isContainerControl(control)) {
        for (const child of control.children) {
            extractStateCore(child, state);
        }
    }
}
exports.extractStateCore = extractStateCore;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29udHJvbEhhbmRsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcnVudGltZS9Db250cm9sSGFuZGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7Ozs7Ozs7O0dBV0c7Ozs7QUFJSCw0REFBdUI7QUFDdkIsMkRBQXdEO0FBQ3hELDZEQUFpRTtBQUNqRSxnRkFBOEU7QUFNOUUsOENBQTJDO0FBQzNDLHlGQUFzRjtBQUN0RixnRkFBbUY7QUFDbkYsNERBQXdEO0FBQ3hELHdEQUF3RDtBQUN4RCw0RUFBMEU7QUFDMUUsdURBQW9EO0FBRXBELE1BQU0sR0FBRyxHQUFHLElBQUksZUFBTSxDQUFDLCtCQUErQixDQUFDLENBQUM7QUFFeEQ7O0dBRUc7QUFDSCxNQUFNLHdCQUF3QjtJQUE5QjtRQUNJLGVBQVUsR0FBVyxDQUFDLENBQUM7SUFDM0IsQ0FBQztDQUFBO0FBU0QsTUFBYSxjQUFjO0lBMEJ2Qjs7OztPQUlHO0lBQ0gsWUFBWSxjQUErQjtRQWpCM0M7Ozs7Ozs7OztXQVNHO1FBQ0gsMkJBQXNCLEdBQUcsSUFBSSxDQUFDLENBQUUsc0RBQXNEO1FBUWxGLElBQUksQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFDO0lBQ3pDLENBQUM7SUFFTyxPQUFPLENBQUMsWUFBMEI7UUFDdEMsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEtBQUssWUFBWSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFO1lBQzNFLE9BQU8sQ0FBQyw4Q0FBOEM7U0FDekQ7UUFDRCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsWUFBWSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDO1FBRXhFLDBDQUEwQztRQUMxQyxNQUFNLGdCQUFnQixHQUFHLFlBQVksQ0FBQyxpQkFBaUIsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDLGNBQWMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ3BILElBQUksQ0FBQyx3QkFBd0IsR0FBRyxn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QUNELEtBQUssQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEdBQUcsT0FBTyxDQUFDLG9CQUFvQixFQUFFLENBQUM7SUFFbkQsSUFBSSxzQ0FBa0IsQ0FBQyxPQUFPLENBQUMsRUFBRTtRQUM3QixLQUFLLE1BQU0sS0FBSyxJQUFJLE9BQU8sQ0FBQyxRQUFRLEVBQUU7WUFDbEMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ2xDO0tBQ0o7QUFDTCxDQUFDO0FBWEQsNENBV0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTkgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIikuXG4gKiBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBBIGNvcHkgb2YgdGhlIExpY2Vuc2UgaXMgbG9jYXRlZCBhdFxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBvciBpbiB0aGUgXCJsaWNlbnNlXCIgZmlsZSBhY2NvbXBhbnlpbmcgdGhpcyBmaWxlLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWRcbiAqIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmdcbiAqIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBIYW5kbGVySW5wdXQsIFJlcXVlc3RIYW5kbGVyIH0gZnJvbSBcImFzay1zZGstY29yZVwiO1xuaW1wb3J0IHsgUmVzcG9uc2UgfSBmcm9tIFwiYXNrLXNkay1tb2RlbFwiO1xuaW1wb3J0IF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgQ29udHJvbElucHV0IH0gZnJvbSAnLi4vY29udHJvbHMvQ29udHJvbElucHV0JztcbmltcG9ydCB7IENvbnRyb2xSZXN1bHRCdWlsZGVyIH0gZnJvbSAnLi4vY29udHJvbHMvQ29udHJvbFJlc3VsdCc7XG5pbXBvcnQgeyBpc0NvbnRhaW5lckNvbnRyb2wgfSBmcm9tICcuLi9jb250cm9scy9pbnRlcmZhY2VzL0lDb250YWluZXJDb250cm9sJztcbmltcG9ydCB7IElDb250cm9sIH0gZnJvbSAnLi4vY29udHJvbHMvaW50ZXJmYWNlcy9JQ29udHJvbCc7XG5pbXBvcnQgeyBJQ29udHJvbElucHV0IH0gZnJvbSAnLi4vY29udHJvbHMvaW50ZXJmYWNlcy9JQ29udHJvbElucHV0JztcbmltcG9ydCB7IElDb250cm9sTWFuYWdlciB9IGZyb20gJy4uL2NvbnRyb2xzL2ludGVyZmFjZXMvSUNvbnRyb2xNYW5hZ2VyJztcbmltcG9ydCB7IElDb250cm9sUmVzdWx0IH0gZnJvbSAnLi4vY29udHJvbHMvaW50ZXJmYWNlcy9JQ29udHJvbFJlc3VsdCc7XG5pbXBvcnQgeyBJQ29udHJvbFJlc3VsdEJ1aWxkZXIgfSBmcm9tICcuLi9jb250cm9scy9pbnRlcmZhY2VzL0lDb250cm9sUmVzdWx0QnVpbGRlcic7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9sb2dnaW5nL0xvZ2dlcic7XG5pbXBvcnQgeyBDb250cm9sUmVzcG9uc2VCdWlsZGVyIH0gZnJvbSAnLi4vcmVzcG9uc2VHZW5lcmF0aW9uL0NvbnRyb2xSZXNwb25zZUJ1aWxkZXInO1xuaW1wb3J0IHsgZ2VuZXJhdGVDb250cm9sVHJlZVRleHREaWFncmFtIH0gZnJvbSAnLi4vdXRpbHMvQ29udHJvbFRyZWVWaXN1YWxpemF0aW9uJztcbmltcG9ydCB7IHZpc2l0Q29udHJvbHMgfSBmcm9tICcuLi91dGlscy9Db250cm9sVmlzaXRvcic7XG5pbXBvcnQgeyByZXF1ZXN0VG9TdHJpbmcgfSBmcm9tICcuLi91dGlscy9SZXF1ZXN0VXRpbHMnO1xuaW1wb3J0IHsgdmFsaWRhdGVTZXJpYWxpemVkU3RhdGUgfSBmcm9tICcuLi91dGlscy9TZXJpYWxpemF0aW9uVmFsaWRhdG9yJztcbmltcG9ydCB7IFNlc3Npb25CZWhhdmlvciB9IGZyb20gJy4vU2Vzc2lvbkJlaGF2aW9yJztcblxuY29uc3QgbG9nID0gbmV3IExvZ2dlcignQXNrU2RrQ29udHJvbHM6Q29udHJvbEhhbmRsZXInKTtcblxuLyoqXG4gKiBTZXNzaW9uIGNvbnRleHQgaW5mb3JtYXRpb24gaW4gYWRkaXRpb24gdG8gdGhhdCBwcm92aWRlZCBieSBBbGV4YSBTZXJ2aWNlLlxuICovXG5jbGFzcyBBZGRpdGlvbmFsU2Vzc2lvbkNvbnRleHQge1xuICAgIHR1cm5OdW1iZXI6IG51bWJlciA9IDA7XG59XG5cbi8qKlxuICogRXh0ZW5kZWQgUmVzcG9uc2UsIHN1cmZhY2luZyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUNvbnRyb2xSZXNwb25zZSBleHRlbmRzIFJlc3BvbnNlIHtcbiAgICBpc1R1cm5FbmRpbmc6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBDb250cm9sSGFuZGxlciBpbXBsZW1lbnRzIFJlcXVlc3RIYW5kbGVyIHtcblxuICAgIHN0YXRpYyBhdHRyaWJ1dGVOYW1lU3RhdGUgPSBcIl9fY29udHJvbFN0YXRlXCI7XG4gICAgc3RhdGljIGF0dHJpYnV0ZU5hbWVDb250ZXh0ID0gXCJfX2NvbnRyb2xDb250ZXh0XCI7XG5cbiAgICBjb250cm9sTWFuYWdlcjogSUNvbnRyb2xNYW5hZ2VyO1xuICAgIHJvb3RDb250cm9sPzogSUNvbnRyb2w7XG5cbiAgICBwcml2YXRlIGFkZGl0aW9uYWxTZXNzaW9uQ29udGV4dDogQWRkaXRpb25hbFNlc3Npb25Db250ZXh0O1xuICAgIHByaXZhdGUgY29udHJvbElucHV0OiBJQ29udHJvbElucHV0O1xuXG4gICAgcHJpdmF0ZSBwcmVwYXJlZFJlcXVlc3RJZDogc3RyaW5nO1xuXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIHRoZSBjb250cm9scyBzdGF0ZSB3aWxsIGJlIGNvcnJlY3RseSByZWVzdGFibGlzaGVkIG9uIHRoZSBuZXh0IHR1cm5cbiAgICAgKlxuICAgICAqIFVzYWdlOlxuICAgICAqICAqIElmIGEgc2tpbGwgdXNlcyBtb3JlIHRoYW4gb25lIENvbnRyb2xIYW5kbGVyLCB0aGUgc3RhdGUgdmFsaWRhdGlvbiBwcm9jZWR1cmUgZ2V0c1xuICAgICAqICAgIGNvbmZ1c2VkIGR1ZSB0byB1bmV4cGVjdGVkIGNvbnRyb2wgc3RhdGVzIGluIHNlc3Npb24gYXR0cmlidXRlcy4gSW4gdGhpcyBzaXR1YXRpb24sXG4gICAgICogICAgc2V0IGB2YWxpZGF0ZVN0YXRlUm91bmR0cmlwID0gZmFsc2VgLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIENvbnRyb2xIYW5kbGVyXG4gICAgICovXG4gICAgdmFsaWRhdGVTdGF0ZVJvdW5kdHJpcCA9IHRydWU7ICAvLyBUT0RPIGltcHJvdmUgdGhlIHZhbGlkYXRpb24gdGVzdGluZyBhbmQgcmVtb3ZlIHRoaXNcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJvbE1hbmFnZXIgQ29udHJvbE1hbmFnZXJcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb250cm9sTWFuYWdlcjogSUNvbnRyb2xNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuY29udHJvbE1hbmFnZXIgPSBjb250cm9sTWFuYWdlcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHByZXBhcmUoaGFuZGxlcklucHV0OiBIYW5kbGVySW5wdXQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMucHJlcGFyZWRSZXF1ZXN0SWQgPT09IGhhbmRsZXJJbnB1dC5yZXF1ZXN0RW52ZWxvcGUucmVxdWVzdC5yZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gZG9uJ3QgcHJlcGFyZSBhZ2FpbiBmb3IgdGhlIHNhbWUgcmVxdWVzdElkLlxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcGFyZWRSZXF1ZXN0SWQgPSBoYW5kbGVySW5wdXQucmVxdWVzdEVudmVsb3BlLnJlcXVlc3QucmVxdWVzdElkO1xuXG4gICAgICAgIC8vIHJldHJpZXZlIGFuZCB1cGRhdGUgdGhlIGNvbnRleHQgb2JqZWN0LlxuICAgICAgICBjb25zdCByZXRyaWV2ZWRDb250ZXh0ID0gaGFuZGxlcklucHV0LmF0dHJpYnV0ZXNNYW5hZ2VyLmdldFNlc3Npb25BdHRyaWJ1dGVzKClbQ29udHJvbEhhbmRsZXIuYXR0cmlidXRlTmFtZUNvbnRleHRdO1xuICAgICAgICB0aGlzLmFkZGl0aW9uYWxTZXNzaW9uQ29udGV4dCA9IHJldHJpZXZlZENvbnRleHQgIT09IHVuZGVmaW5lZCA/IEpTT04ucGFyc2UocmV0cmlldmVkQ29udGV4dCkgOiBuZXcgQWRkaXRpb25hbFNlc3Npb25Db250ZXh0KCk7XG4gICAgICAgIHRoaXMuYWRkaXRpb25hbFNlc3Npb25Db250ZXh0LnR1cm5OdW1iZXIgKz0gMTtcblxuICAgICAgICAvLyByZXRyaWV2ZSB0aGUgY29udHJvbCBzdGF0ZVxuICAgICAgICBjb25zdCBzdGF0ZU1hcCA9IHRoaXMuZ2V0U3RhdGVNYXBGcm9tU2Vzc2lvbkF0dHJpYnV0ZXMoaGFuZGxlcklucHV0KTtcblxuXG4gICAgICAgIC8vIGJ1aWxkIHRoZSBjb250cm9sIHRyZWUgYW5kIGF0dGFjaCBzdGF0ZVxuICAgICAgICB0aGlzLnJvb3RDb250cm9sID0gdGhpcy5jb250cm9sTWFuYWdlci5jcmVhdGVDb250cm9sVHJlZShzdGF0ZU1hcCk7XG4gICAgICAgIGF0dGFjaFN0YXRlVG9Db250cm9sVHJlZSh0aGlzLnJvb3RDb250cm9sLCBzdGF0ZU1hcCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBpbnB1dCBvYmplY3QgZm9yIHVzZSBpbiB0aGUgbWFpbiBwcm9jZXNzaW5nLlxuICAgICAgICBjb25zdCBjb250cm9scyA9IENvbnRyb2xIYW5kbGVyLmNyZWF0ZUNvbnRyb2xNYXAodGhpcy5yb290Q29udHJvbCwge30pO1xuICAgICAgICB0aGlzLmNvbnRyb2xJbnB1dCA9IG5ldyBDb250cm9sSW5wdXQoaGFuZGxlcklucHV0LCB0aGlzLmFkZGl0aW9uYWxTZXNzaW9uQ29udGV4dC50dXJuTnVtYmVyLCBjb250cm9scyk7XG4gICAgfVxuXG5cbiAgICBwcml2YXRlIGdldFN0YXRlTWFwRnJvbVNlc3Npb25BdHRyaWJ1dGVzKGhhbmRsZXJJbnB1dDogSGFuZGxlcklucHV0KSB7XG4gICAgICAgIGNvbnN0IHJldHJpZXZlZFN0YXRlSlNPTiA9IGhhbmRsZXJJbnB1dC5hdHRyaWJ1dGVzTWFuYWdlci5nZXRTZXNzaW9uQXR0cmlidXRlcygpW0NvbnRyb2xIYW5kbGVyLmF0dHJpYnV0ZU5hbWVTdGF0ZV07XG4gICAgICAgIGNvbnN0IHN0YXRlTWFwID0gcmV0cmlldmVkU3RhdGVKU09OICE9PSB1bmRlZmluZWQgPyBKU09OLnBhcnNlKHJldHJpZXZlZFN0YXRlSlNPTikgOiB7fTtcbiAgICAgICAgcmV0dXJuIHN0YXRlTWFwO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGNyZWF0ZUNvbnRyb2xNYXAoY29udHJvbDogSUNvbnRyb2wsIG1hcEFjYzogeyBbaW5kZXg6IHN0cmluZ106IElDb250cm9sIH0pOiB7IFtpbmRleDogc3RyaW5nXTogSUNvbnRyb2wgfSB7XG4gICAgICAgIG1hcEFjY1tjb250cm9sLmlkXSA9IGNvbnRyb2w7XG4gICAgICAgIGlmIChpc0NvbnRhaW5lckNvbnRyb2woY29udHJvbCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgKGNvbnRyb2wgYXMgYW55KS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIENvbnRyb2xIYW5kbGVyLmNyZWF0ZUNvbnRyb2xNYXAoY2hpbGQsIG1hcEFjYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcEFjYzsgLy8gcmV0dXJuaW5nIHRoZSBhY2N1bXVsYXRvciBhbGxvd3MgdGhlIGNhbGwtc2l0ZSB0byBiZSBtb3JlIHJlYWRhYmxlXG4gICAgfVxuXG4gICAgYXN5bmMgY2FuSGFuZGxlKGhhbmRsZXJJbnB1dDogSGFuZGxlcklucHV0KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnByZXBhcmUoaGFuZGxlcklucHV0KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3RDb250cm9sIS5jYW5IYW5kbGUodGhpcy5jb250cm9sSW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbE1hbmFnZXIuaGFuZGxlSW50ZXJuYWxFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbE1hbmFnZXIuaGFuZGxlSW50ZXJuYWxFcnJvcih0aGlzLmNvbnRyb2xJbnB1dCwgZXJyb3IsIGhhbmRsZXJJbnB1dC5yZXNwb25zZUJ1aWxkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7IC8vIHJldGhyb3cgc28gdG9wLWxldmVsIG9ic2VydmVzIGl0IHRvby5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGhhbmRsZShoYW5kbGVySW5wdXQ6IEhhbmRsZXJJbnB1dCwgcHJvY2Vzc0lucHV0ID0gdHJ1ZSk6IFByb21pc2U8SUNvbnRyb2xSZXNwb25zZT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlKGhhbmRsZXJJbnB1dCk7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBQcm9jZXNzIHRoZSB0dXJuIHRocm91Z2ggdGhlIGFwcGxpY2F0aW9uLlxuICAgICAgICAgICAgICogRG8gdGhlIHdvcmsgKHN0YXRlIHVwZGF0ZXMgYW5kIGRpYWxvZyBwb2xpY3kpXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCdWlsZGVyID0gbmV3IENvbnRyb2xSZXNwb25zZUJ1aWxkZXIoaGFuZGxlcklucHV0LnJlc3BvbnNlQnVpbGRlcik7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRCdWlsZGVyID0gbmV3IENvbnRyb2xSZXN1bHRCdWlsZGVyKCk7XG4gICAgICAgICAgICBhd2FpdCBDb250cm9sSGFuZGxlci5oYW5kbGVDb3JlKHRoaXMucm9vdENvbnRyb2whLCB0aGlzLmNvbnRyb2xJbnB1dCwgcmVzdWx0QnVpbGRlciwgcHJvY2Vzc0lucHV0KTtcblxuICAgICAgICAgICAgLy8gQ29tcG9zZSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5idWlsZFJlc3BvbnNlQ29yZShyZXN1bHRCdWlsZGVyLmJ1aWxkKCksIHJlc3BvbnNlQnVpbGRlciwgdGhpcy5jb250cm9sSW5wdXQpO1xuXG4gICAgICAgICAgICAvLyBDb2xsYXRlIHRoZSBDb250cm9sIHN0YXRlIG9iamVjdHMgZm9yIHNlcmlhbGl6YXRpb25cblxuICAgICAgICAgICAgLyogTm90ZTogd2UgbWVyZ2Ugb250byB0aGUgcHJldmFpbGluZyBzdGF0ZSBmb3IgdGhlIGVkZ2UtY2FzZSBvZiBtdWx0aXBsZSBDb250cm9sSGFuZGxlcnMgaW4gdGhlIHNraWxsIHRoYXQgYXJlIGFjdGl2ZSBvbiBkaWZmZXJlbnQgdHVybnMuXG4gICAgICAgICAgICAgKiAgICAgICBtZXJnaW5nIGF2b2lkIG9uZSBjb250cm9sSGFuZGxlciBzdG9tcGluZyBvbiB0aGUgc3RhdGUgb2YgdGhlIG90aGVyLiAgQ29udGV4dCBpcyBjdXJyZW50bHkgT0svZ29vZCB0byBiZSBzdG9tcGVkIG9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBwcmlvclN0YXRlTWFwID0gdGhpcy5nZXRTdGF0ZU1hcEZyb21TZXNzaW9uQXR0cmlidXRlcyhoYW5kbGVySW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXRlTWFwID0gdGhpcy5nZXRTZXJpYWxpemFibGVDb250cm9sU3RhdGVzKCk7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRTdGF0ZU1hcCA9IHsuLi5wcmlvclN0YXRlTWFwLCAuLi5jdXJyZW50U3RhdGVNYXB9O1xuXG4gICAgICAgICAgICBjb25zdCBzdGF0ZVRvU2F2ZUpzb24gPSBKU09OLnN0cmluZ2lmeShtZXJnZWRTdGF0ZU1hcCwgbnVsbCwgMik7XG4gICAgICAgICAgICBsb2cuaW5mbyhgU2F2aW5nIHN0YXRlLi4uXFxuJHtzdGF0ZVRvU2F2ZUpzb259IGApO1xuXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0VG9TYXZlSnNvbiA9IEpTT04uc3RyaW5naWZ5KHRoaXMuYWRkaXRpb25hbFNlc3Npb25Db250ZXh0LCBudWxsLCAyKTtcbiAgICAgICAgICAgIGxvZy5pbmZvKGBTYXZpbmcgY29udGV4dC4uLlxcbiR7Y29udGV4dFRvU2F2ZUpzb259YCk7XG5cbiAgICAgICAgICAgIHRoaXMuY29udHJvbElucHV0LmhhbmRsZXJJbnB1dC5hdHRyaWJ1dGVzTWFuYWdlci5nZXRTZXNzaW9uQXR0cmlidXRlcygpW0NvbnRyb2xIYW5kbGVyLmF0dHJpYnV0ZU5hbWVTdGF0ZV0gPSBzdGF0ZVRvU2F2ZUpzb247XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xJbnB1dC5oYW5kbGVySW5wdXQuYXR0cmlidXRlc01hbmFnZXIuZ2V0U2Vzc2lvbkF0dHJpYnV0ZXMoKVtDb250cm9sSGFuZGxlci5hdHRyaWJ1dGVOYW1lQ29udGV4dF0gPSBjb250ZXh0VG9TYXZlSnNvbjtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgc2VyaWFsaXplZCBzdGF0ZSB3aWxsIHN1cnZpdmUgdGhlIHJvdW5kIHRyaXBcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkYXRlU3RhdGVSb3VuZHRyaXApe1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlU2VyaWFsaXplZFN0YXRlKHN0YXRlVG9TYXZlSnNvbiwgdGhpcy5jb250cm9sTWFuYWdlciwgdGhpcy5jb250cm9sSW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udHJvbE1hbmFnZXIuaGFuZGxlSW50ZXJuYWxFcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udHJvbE1hbmFnZXIuaGFuZGxlSW50ZXJuYWxFcnJvcih0aGlzLmNvbnRyb2xJbnB1dCwgZXJyb3IsIGhhbmRsZXJJbnB1dC5yZXNwb25zZUJ1aWxkZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyAuLi5oYW5kbGVySW5wdXQucmVzcG9uc2VCdWlsZGVyLmdldFJlc3BvbnNlKCksIGlzVHVybkVuZGluZzogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHN0cmluZyAnQzo8bkNvbnRyb2xzPicgZm9yIGluY2x1c2lvbiBpbiBVc2VyQWdlbnQgdG8gaW5kaWNhdGUgdXNhZ2UuXG4gICAgICpcbiAgICAgKiBUaGUgaW5mb3JtYXRpb24gZ2F0aGVyZWQgaXMgb25seSB0aGUgbnVtYmVyIG9mIENvbnRyb2xzIGJlaW5nIHVzZWQuXG4gICAgICogVGhpcyB3aWxsIGhlbHAgdGhlIGRldiB0ZWFtIHRvIHVuZGVyc3RhbmQgdXNhZ2UgLSB0aGFuayB5b3UhXG4gICAgICovXG4gICAgdXNlckFnZW50SW5mbygpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCByb290Q29udHJvbCA9IHRoaXMucm9vdENvbnRyb2wgPz8gdGhpcy5jb250cm9sTWFuYWdlci5jcmVhdGVDb250cm9sVHJlZSh7fSk7XG4gICAgICAgIGxldCBuQ29udHJvbHMgPSAwO1xuICAgICAgICB2aXNpdENvbnRyb2xzKHJvb3RDb250cm9sLCAoKSA9PiB7IG5Db250cm9scysrOyB9KTtcbiAgICAgICAgcmV0dXJuIGBuQ3RybDoke25Db250cm9sc31gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgdGhlIGNvcmUgb2YgcHJvY2Vzc2luZywgd2hpY2ggIGlzIGhhbmRsZShyZXF1ZXN0KSAtPiBIYW5kbGVSZXN1bHQgKyBzdGF0ZSB1cGRhdGVzXG4gICAgICogUHVibGljIGZvciB0ZXN0aW5nLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0XG4gICAgICogQHBhcmFtIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGVJbnB1dCB3aGV0aGVyIHRvIGhhbmRsZSB0aGUgaW5wdXQuIGlmIGZhbHNlLCBwcm9jZXNzaW5nIHNraXBzIHRvIHRoZSBpbml0aWF0aXZlIHBoYXNlLlxuICAgICAqXG4gICAgICogcmV0dXJucyBbY29udHJvbFJlc3VsdCwgc2hvdWxkRW5kU2Vzc2lvbl1cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGhhbmRsZUNvcmUocm9vdENvbnRyb2w6IElDb250cm9sLCBpbnB1dDogSUNvbnRyb2xJbnB1dCwgcmVzdWx0QnVpbGRlcjogSUNvbnRyb2xSZXN1bHRCdWlsZGVyLCBoYW5kbGVJbnB1dCA9IHRydWUpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgbG9nLmluZm8oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIpO1xuICAgICAgICBsb2cuaW5mbyhgVHVybiAke2lucHV0LnR1cm5OdW1iZXJ9IHN0YXJ0ZWRgKTtcbiAgICAgICAgbG9nLmluZm8oYElucHV0OiAke3JlcXVlc3RUb1N0cmluZyhpbnB1dC5oYW5kbGVySW5wdXQucmVxdWVzdEVudmVsb3BlLnJlcXVlc3QpfWApO1xuICAgICAgICBsb2cuaW5mbyhgVUkgYXQgc3RhcnQ6IFxcbiR7Z2VuZXJhdGVDb250cm9sVHJlZVRleHREaWFncmFtKHJvb3RDb250cm9sLCBpbnB1dC50dXJuTnVtYmVyKX1gKTtcblxuICAgICAgICBpZiAoaGFuZGxlSW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbkhhbmRsZVJlc3BvbnNlID0gYXdhaXQgcm9vdENvbnRyb2wuY2FuSGFuZGxlKGlucHV0KTtcblxuICAgICAgICAgICAgaWYgKCFjYW5IYW5kbGVSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiICpXQVJOKiByb290Q29udHJvbCByZXR1cm5lZCBjYW5IYW5kbGU9ZmFsc2UuICBDbG9zaW5nIHNlc3Npb25cIik7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oYFVJIGF0IGVuZCBvZiB0dXJuOiBcXG4ke2dlbmVyYXRlQ29udHJvbFRyZWVUZXh0RGlhZ3JhbShyb290Q29udHJvbCwgaW5wdXQudHVybk51bWJlcil9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIQU5ETEVcbiAgICAgICAgICAgIGF3YWl0IHJvb3RDb250cm9sLmhhbmRsZShpbnB1dCwgcmVzdWx0QnVpbGRlcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPcHRpb25hbCBJTklUSUFUSVZFIFBIQVNFXG4gICAgICAgIGlmICghcmVzdWx0QnVpbGRlci5oYXNJbml0aWF0aXZlQWN0KCkgJiYgcmVzdWx0QnVpbGRlci5zZXNzaW9uQmVoYXZpb3IgPT09IFNlc3Npb25CZWhhdmlvci5PUEVOKSB7XG4gICAgICAgICAgICBhd2FpdCBDb250cm9sSGFuZGxlci5pbml0aWF0aXZlUGhhc2Uocm9vdENvbnRyb2wsIGlucHV0LCByZXN1bHRCdWlsZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IHRyYWNrIHRoZSBzcGVjaWZpYyBjb250cm9sSUQgdGhhdCBnZW5lcmF0ZWQgdGhlIGluaXRpYXRpdmUuIG1ha2UgaXQgYXZhaWxhYmxlIHNvIHRoYXQgY29udHJvbHNcbiAgICAgICAgLy8gY2FuIHVzZSBhIGhhc0luaXRpYXRpdmUoKSBwcmVkaWNhdGUgYW5kIHJlYXNvbiBhYm91dCB3aGV0aGVyIHRoZXkgYXJlIGFjdGl2ZWx5IHJ1bm5pbmcgdGhlIGNvbnZlcnNhdGlvbi5cblxuICAgICAgICBsb2cuaW5mbyhgSGFuZGxlUmVzcG9uc2U6ICR7cmVzdWx0QnVpbGRlcn1gKTtcbiAgICAgICAgbG9nLmluZm8oYFVJIGF0IGVuZCBvZiB0dXJuOiBcXG4ke2dlbmVyYXRlQ29udHJvbFRyZWVUZXh0RGlhZ3JhbShyb290Q29udHJvbCwgaW5wdXQudHVybk51bWJlcil9YCk7XG4gICAgfVxuXG5cbiAgICBwdWJsaWMgc3RhdGljIGFzeW5jIGluaXRpYXRpdmVQaGFzZShyb290Q29udHJvbDogSUNvbnRyb2wsIGlucHV0OiBJQ29udHJvbElucHV0LCByZXN1bHRCdWlsZGVyOiBJQ29udHJvbFJlc3VsdEJ1aWxkZXIpOiBQcm9taXNlPHZvaWQ+IHtcblxuICAgICAgICBsb2cuZGVidWcoYFVJIGF0IHN0YXJ0IG9mIGluaXRpYXRpdmUgcGhhc2U6IFxcbiR7Z2VuZXJhdGVDb250cm9sVHJlZVRleHREaWFncmFtKHJvb3RDb250cm9sLCBpbnB1dC50dXJuTnVtYmVyKX1gKTtcbiAgICAgICAgY29uc3QgY2FuVGFrZUluaXRpYXRpdmUgPSBhd2FpdCByb290Q29udHJvbC5jYW5UYWtlSW5pdGlhdGl2ZShpbnB1dCk7XG4gICAgICAgIGlmIChjYW5UYWtlSW5pdGlhdGl2ZSkge1xuICAgICAgICAgICAgYXdhaXQgcm9vdENvbnRyb2wudGFrZUluaXRpYXRpdmUoaW5wdXQsIHJlc3VsdEJ1aWxkZXIpO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3VsdEJ1aWxkZXIuaGFzSW5pdGlhdGl2ZUFjdCgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU29tZXRoaW5nIHJlc3BvbmRlZCB3aXRoIGBjYW5UYWtlSW5pdGlhdGl2ZT10cnVlYCBidXQgbm8gaW5pdGlhdGl2ZSBpdGVtIHdhcyBwcm9kdWNlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoXCJFbmQgb2YgaGFuZGxlOiBub3RoaW5nIHdhbnRlZCB0byB0YWtlIGluaXRpYXRpdmUuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRha2UgdGhlIGluaXRpYXRpdmUgaW4gdGhlIGRpYWxvZy5cbiAgICAgKlxuICAgICAqIEFueSBleGlzdGluZyBjb250ZW50IGluIHRoZSBSZXNwb25zZSdzIHByb21wdCAmIHJlcHJvbXB0IGlzIG92ZXJ3cml0dGVuLiBUbyBhdm9pZCBsb3NpbmcgdGhpcyBjb250ZW50LCBwYXNzIGl0XG4gICAgICogaW4gdXNpbmcgcGFyYW1ldGVycyBwcm9tcHRQcmVmaXggJiByZXByb21wdFByZWZpeC5cbiAgICAgKlxuICAgICAqIFVzYWdlOlxuICAgICAqICAqIFRoaXMgbWV0aG9kIGlzIHR5cGljYWxseSB1c2VkIHRvIHRyYW5zaXRpb24gZnJvbSBhIHJlZ3VsYXIgUmVxdWVzdEhhbmRsZXIgaW50byBDb250cm9sc1xuICAgICAqICAgIEZvciBleGFtcGxlLCB3aGVuIGEgcmVndWxhciBSZXF1ZXN0SGFuZGxlciBjb25zdW1lcyB0aGUgaW5wdXQgYnV0IGRvZXNuJ3Qgd2FudCB0byBrZWVwIHRoZSBpbml0aWF0aXZlLCBpdCBjYW4gYXNrXG4gICAgICogICAgYSBDb250cm9sSGFuZGxlciB0byB0YWtlIHRoZSBpbml0aWF0aXZlIHRvIGNvbXBsZXRlIHRoZSB0dXJuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZXJJbnB1dFxuICAgICAqIEBwYXJhbSBwcm9tcHRQcmVmaXhcbiAgICAgKiBAcGFyYW0gcmVwcm9tcHRQcmVmaXhcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgdGFrZUluaXRpYXRpdmUoaGFuZGxlcklucHV0OiBIYW5kbGVySW5wdXQsIHByb21wdFByZWZpeDogc3RyaW5nLCByZXByb21wdFByZWZpeD86IHN0cmluZyk6IFByb21pc2U8SUNvbnRyb2xSZXNwb25zZT4ge1xuXG4gICAgICAgIGlmIChyZXByb21wdFByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXByb21wdFByZWZpeCA9IHByb21wdFByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIE5PVEU6IHdlIGNhbGwgaGFuZGxlKC4uLCBmYWxzZSkgcmF0aGVyIHRoYW4gZGlyZWN0bHkgY2FsbGluZyBpbml0aWF0aXZlUGhhc2UoKSBhcyB3ZSBuZWVkIGFsbFxuICAgICAgICAgKiB0aGUgdXN1YWwgdHVybiBib29rLWtlZXBpbmcgKHByZXBhcmUsIGxvZ2dpbmcsIHN0YXRlIGxvYWRpbmcgJiBzYXZpbmcpIHRvIG9jY3VyXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuaGFuZGxlKGhhbmRsZXJJbnB1dCwgZmFsc2UpO1xuICAgICAgICBjb25zdCBbcHJvbXB0LCByZXByb21wdF0gPSBDb250cm9sSGFuZGxlci5nZXRQcm9tcHRBbmRSZXByb21wdEZyb21SZXNwb25zZShyZXNwb25zZSk7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLm91dHB1dFNwZWVjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXNwb25zZS5vdXRwdXRTcGVlY2ggPSB7IHR5cGU6ICdQbGFpblRleHQnLCB0ZXh0OiBwcm9tcHRQcmVmaXggfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5vdXRwdXRTcGVlY2gudHlwZSA9PT0gJ1NTTUwnKSB7XG4gICAgICAgICAgICByZXNwb25zZS5vdXRwdXRTcGVlY2ggPSB7IHR5cGU6ICdTU01MJywgc3NtbDogcHJvbXB0LnJlcGxhY2UoJzxzcGVhaz4nLCBgPHNwZWFrPiR7cHJvbXB0UHJlZml4fWApIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNwb25zZS5vdXRwdXRTcGVlY2ggPSB7IHR5cGU6ICdQbGFpblRleHQnLCB0ZXh0OiBwcm9tcHRQcmVmaXggKyBwcm9tcHQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwb25zZS5yZXByb21wdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXNwb25zZS5yZXByb21wdCA9IHsgb3V0cHV0U3BlZWNoOiB7IHR5cGU6ICdQbGFpblRleHQnLCB0ZXh0OiByZXByb21wdFByZWZpeCB9IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzcG9uc2UucmVwcm9tcHQub3V0cHV0U3BlZWNoLnR5cGUgPT09ICdTU01MJykge1xuICAgICAgICAgICAgcmVzcG9uc2UucmVwcm9tcHQub3V0cHV0U3BlZWNoID0geyB0eXBlOiAnU1NNTCcsIHNzbWw6IHJlcHJvbXB0LnJlcGxhY2UoJzxzcGVhaz4nLCBgPHNwZWFrPiR7cmVwcm9tcHRQcmVmaXh9YCkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3BvbnNlLnJlcHJvbXB0Lm91dHB1dFNwZWVjaCA9IHsgdHlwZTogJ1BsYWluVGV4dCcsIHRleHQ6IHJlcHJvbXB0UHJlZml4ICsgcmVwcm9tcHQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0UHJvbXB0QW5kUmVwcm9tcHRGcm9tUmVzcG9uc2UocmVzcG9uc2U6IElDb250cm9sUmVzcG9uc2UpOiBbc3RyaW5nLCBzdHJpbmddIHtcbiAgICAgICAgY29uc3QgcHJvbXB0ID0gcmVzcG9uc2Uub3V0cHV0U3BlZWNoID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgIDogKHJlc3BvbnNlLm91dHB1dFNwZWVjaC50eXBlID09PSAnU1NNTCcpXG4gICAgICAgICAgICAgICAgPyByZXNwb25zZS5vdXRwdXRTcGVlY2guc3NtbC5yZXBsYWNlKCc8c3NtbD4nLCAnJykucmVwbGFjZSgnPC9zc21sPicsICcnKVxuICAgICAgICAgICAgICAgIDogcmVzcG9uc2Uub3V0cHV0U3BlZWNoLnRleHQ7XG5cbiAgICAgICAgY29uc3QgcmVwcm9tcHQgPSByZXNwb25zZS5yZXByb21wdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/ICcnXG4gICAgICAgICAgICA6IChyZXNwb25zZS5yZXByb21wdC5vdXRwdXRTcGVlY2gudHlwZSA9PT0gJ1NTTUwnKVxuICAgICAgICAgICAgICAgID8gcmVzcG9uc2UucmVwcm9tcHQub3V0cHV0U3BlZWNoLnNzbWwucmVwbGFjZSgnPHNzbWw+JywgJycpLnJlcGxhY2UoJzwvc3NtbD4nLCAnJylcbiAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLnJlcHJvbXB0Lm91dHB1dFNwZWVjaC50ZXh0O1xuICAgICAgICByZXR1cm4gW3Byb21wdCwgcmVwcm9tcHRdO1xuICAgIH1cblxuXG4gICAgYXN5bmMgYnVpbGRSZXNwb25zZUNvcmUocmVzdWx0OiBJQ29udHJvbFJlc3VsdCwgY29udHJvbFJlc3BvbnNlQnVpbGRlcjogQ29udHJvbFJlc3BvbnNlQnVpbGRlciwgaW5wdXQ6IElDb250cm9sSW5wdXQpOiBQcm9taXNlPElDb250cm9sUmVzcG9uc2U+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb250cm9sTWFuYWdlci5yZW5kZXIocmVzdWx0LCBpbnB1dCwgY29udHJvbFJlc3BvbnNlQnVpbGRlcik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gY29udHJvbFJlc3BvbnNlQnVpbGRlci5nZXRSZXNwb25zZSgpO1xuICAgICAgICBzd2l0Y2ggKHJlc3VsdC5zZXNzaW9uQmVoYXZpb3IpIHtcbiAgICAgICAgICAgIGNhc2UgU2Vzc2lvbkJlaGF2aW9yLk9QRU46IHJlc3BvbnNlLnNob3VsZEVuZFNlc3Npb24gPSBmYWxzZTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNlc3Npb25CZWhhdmlvci5FTkQ6IHJlc3BvbnNlLnNob3VsZEVuZFNlc3Npb24gPSB0cnVlOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2Vzc2lvbkJlaGF2aW9yLklETEU6IHJlc3BvbnNlLnNob3VsZEVuZFNlc3Npb24gPSB1bmRlZmluZWQ7IGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIFNlc3Npb25CZWhhdmlvciB2YWx1ZTogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgLi4ucmVzcG9uc2UsIGlzVHVybkVuZGluZzogcmVzdWx0Lmhhc0luaXRpYXRpdmVBY3QoKSB9O1xuICAgIH1cblxuXG4gICAgcHVibGljIGdldFNlcmlhbGl6YWJsZUNvbnRyb2xTdGF0ZXMoKTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSB7XG4gICAgICAgIHJldHVybiBleHRyYWN0U3RhdGVGcm9tQ29udHJvbFRyZWUodGhpcy5yb290Q29udHJvbCEpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBWaXNpdHMgZWFjaCBjb250cm9sIGluIHRoZSB0cmVlIGFuZCBhdHRhY2hlcyB0aGUgY29ycmVzcG9uZGluZyBzdGF0ZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0gcm9vdENvbnRyb2wgcm9vdFxuICogQHBhcmFtIHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhdHRhY2hTdGF0ZVRvQ29udHJvbFRyZWUocm9vdENvbnRyb2w6IElDb250cm9sLCBzdGF0ZTogYW55KSB7XG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBteVN0YXRlID0gc3RhdGVbcm9vdENvbnRyb2wuaWRdO1xuICAgIGlmIChteVN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcm9vdENvbnRyb2wuc2V0U2VyaWFsaXphYmxlU3RhdGUobXlTdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ29udGFpbmVyQ29udHJvbChyb290Q29udHJvbCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiByb290Q29udHJvbC5jaGlsZHJlbikge1xuICAgICAgICAgICAgYXR0YWNoU3RhdGVUb0NvbnRyb2xUcmVlKGNoaWxkLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogVmlzaXRzIGVhY2ggY29udHJvbHMgYW5kIGNvbGxhdGVzIHRoZSBzdGF0ZSBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSByb290Q29udHJvbFxuICogQHBhcmFtIHByaW9yU3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RTdGF0ZUZyb21Db250cm9sVHJlZShyb290Q29udHJvbDogSUNvbnRyb2wpOiB7IFtrZXk6IHN0cmluZ106IGFueSB9IHtcbiAgICBjb25zdCBzdGF0ZU9iajogYW55ID0ge307XG4gICAgZXh0cmFjdFN0YXRlQ29yZShyb290Q29udHJvbCwgc3RhdGVPYmopO1xuICAgIHJldHVybiBzdGF0ZU9iajtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RTdGF0ZUNvcmUoY29udHJvbDogSUNvbnRyb2wsIHN0YXRlOiBhbnkpIHtcbiAgICBpZiAoXy5oYXMoc3RhdGUsIGNvbnRyb2wuaWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGNvbnRyb2wgaWQ6ICR7Y29udHJvbC5pZH1gKTtcbiAgICB9XG4gICAgc3RhdGVbY29udHJvbC5pZF0gPSBjb250cm9sLmdldFNlcmlhbGl6YWJsZVN0YXRlKCk7XG5cbiAgICBpZiAoaXNDb250YWluZXJDb250cm9sKGNvbnRyb2wpKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY29udHJvbC5jaGlsZHJlbikge1xuICAgICAgICAgICAgZXh0cmFjdFN0YXRlQ29yZShjaGlsZCwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19