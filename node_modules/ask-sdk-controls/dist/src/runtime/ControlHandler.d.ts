import { HandlerInput, RequestHandler } from "ask-sdk-core";
import { Response } from "ask-sdk-model";
import { IControl } from '../controls/interfaces/IControl';
import { IControlInput } from '../controls/interfaces/IControlInput';
import { IControlManager } from '../controls/interfaces/IControlManager';
import { IControlResult } from '../controls/interfaces/IControlResult';
import { IControlResultBuilder } from '../controls/interfaces/IControlResultBuilder';
import { ControlResponseBuilder } from '../responseGeneration/ControlResponseBuilder';
/**
 * Extended Response, surfacing additional information
 */
export interface IControlResponse extends Response {
    isTurnEnding: boolean;
}
export declare class ControlHandler implements RequestHandler {
    static attributeNameState: string;
    static attributeNameContext: string;
    controlManager: IControlManager;
    rootControl?: IControl;
    private additionalSessionContext;
    private controlInput;
    private preparedRequestId;
    /**
     * Determines if the controls state will be correctly reestablished on the next turn
     *
     * Usage:
     *  * If a skill uses more than one ControlHandler, the state validation procedure gets
     *    confused due to unexpected control states in session attributes. In this situation,
     *    set `validateStateRoundtrip = false`.
     *
     * @memberof ControlHandler
     */
    validateStateRoundtrip: boolean;
    /**
     *
     *
     * @param controlManager ControlManager
     */
    constructor(controlManager: IControlManager);
    private prepare;
    private getStateMapFromSessionAttributes;
    private static createControlMap;
    canHandle(handlerInput: HandlerInput): Promise<boolean>;
    handle(handlerInput: HandlerInput, processInput?: boolean): Promise<IControlResponse>;
    /**
     * Creates a string 'C:<nControls>' for inclusion in UserAgent to indicate usage.
     *
     * The information gathered is only the number of Controls being used.
     * This will help the dev team to understand usage - thank you!
     */
    userAgentInfo(): string;
    /**
     * Implements the core of processing, which  is handle(request) -> HandleResult + state updates
     * Public for testing.
     * @param request
     * @param context
     *
     * @param handleInput whether to handle the input. if false, processing skips to the initiative phase.
     *
     * returns [controlResult, shouldEndSession]
     */
    static handleCore(rootControl: IControl, input: IControlInput, resultBuilder: IControlResultBuilder, handleInput?: boolean): Promise<void>;
    static initiativePhase(rootControl: IControl, input: IControlInput, resultBuilder: IControlResultBuilder): Promise<void>;
    /**
     * Take the initiative in the dialog.
     *
     * Any existing content in the Response's prompt & reprompt is overwritten. To avoid losing this content, pass it
     * in using parameters promptPrefix & repromptPrefix.
     *
     * Usage:
     *  * This method is typically used to transition from a regular RequestHandler into Controls
     *    For example, when a regular RequestHandler consumes the input but doesn't want to keep the initiative, it can ask
     *    a ControlHandler to take the initiative to complete the turn.
     *
     * @param handlerInput
     * @param promptPrefix
     * @param repromptPrefix
     */
    takeInitiative(handlerInput: HandlerInput, promptPrefix: string, repromptPrefix?: string): Promise<IControlResponse>;
    static getPromptAndRepromptFromResponse(response: IControlResponse): [string, string];
    buildResponseCore(result: IControlResult, controlResponseBuilder: ControlResponseBuilder, input: IControlInput): Promise<IControlResponse>;
    getSerializableControlStates(): {
        [key: string]: any;
    };
}
/**
 * Visits each control in the tree and attaches the corresponding state object
 *
 * @param rootControl root
 * @param state
 */
export declare function attachStateToControlTree(rootControl: IControl, state: any): void;
/**
 * Visits each controls and collates the state objects.
 *
 * @param rootControl
 * @param priorState
 */
export declare function extractStateFromControlTree(rootControl: IControl): {
    [key: string]: any;
};
export declare function extractStateCore(control: IControl, state: any): void;
//# sourceMappingURL=ControlHandler.d.ts.map