"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const mocha_1 = require("mocha");
const sinon_1 = tslib_1.__importDefault(require("sinon"));
const src_1 = require("../src");
const Control_1 = require("../src/controls/Control");
const ControlManager_1 = require("../src/controls/ControlManager");
const GeneralControlIntent_1 = require("../src/intents/GeneralControlIntent");
const TestingUtils_1 = require("../src/utils/testSupport/TestingUtils");
class RenderingDemoControl extends Control_1.Control {
    canHandle(input) {
        return true;
    }
    handle(input, resultBuilder) {
        // Adds three system acts to the result for demonstration purposes.
        /* The UnusableInputValueAct act includes some surface information (renderedReason) so that the act can use default render logic
         * This breaks the separation of Controller & View, but can be handy for simple cases. The simplest acts, e.g. ValueSetAct,
         * don't require any data for their defaults.
         *
         * Production code will likely not use this approach.
         */
        resultBuilder.addAct(new src_1.UnusableInputValueAct(this, { reasonCode: 'exampleReasonCode', value: '<dummy>', renderedReason: 'That input is unusable for reasons' }));
        /*
         * The next two are 'pure' acts that will be translated during the render-phase.
         * The InvalidValueAct is rendered by this Control in renderAct().  This is the most common approach.
         * The RequestValueAct is rendered by the ControlManager in render(). This is used when full control is necessary, such as to render two acts as a cohesive pair.
         */
        resultBuilder.addAct(new src_1.InvalidValueAct(this, { reasonCode: 'exampleReasonCode', value: '<dummy>' }));
        resultBuilder.addAct(new src_1.RequestValueAct(this, {}));
    }
    canTakeInitiative(input) {
        return false;
    }
    takeInitiative(input, resultBuilder) {
    }
    renderAct(act, input, responseBuilder) {
        if (act instanceof src_1.InvalidValueAct) {
            responseBuilder.addPromptFragment('The current value is invalid.'); // <<---- 'rendering by Control'. this is the most common approach
        }
        else {
            super.renderAct(act, input, responseBuilder); // <<---- super.renderAct delegates to act.render(). this is 'self-render'. see UnusableInputValueAct.render()
        }
    }
}
class RenderingDemoControlManager extends ControlManager_1.ControlManager {
    createControlTree(state, input) {
        return new RenderingDemoControl('root');
    }
    render(result, input, controlResponseBuilder) {
        for (const act of result.acts) {
            if (act instanceof src_1.RequestValueAct) {
                controlResponseBuilder.addPromptFragment('How many ducks?'); // <<---- 'render by ControlManager'.. this offers maximum power.
            }
            else {
                act.control.renderAct(act, input, controlResponseBuilder); // <<---- the general case is to 'render by Control'
            }
        }
    }
}
/**
 * Demonstrate standard ControlState object but with different Controls to handle them
 * the choice of control to use is by controlState.type and by registering the control types
 * with the UserInterface so that it can function as a control factory.
 */
mocha_1.suite("== Result rendering (renderingResult.spec.ts) ==", () => {
    mocha_1.test("Demonstrate SystemAct self-render & rendering overrides.", async () => {
        const requestHandler = new src_1.ControlHandler(new RenderingDemoControlManager());
        const invoker = new src_1.SkillInvoker(requestHandler);
        await TestingUtils_1.testTurn(invoker, 'U: ', TestingUtils_1.TestInput.of(GeneralControlIntent_1.GeneralControlIntent.of({})), 'A: Sorry, That input is unusable for reasons. The current value is invalid. How many ducks?');
    });
});
mocha_1.suite("== i18n overrides scenarios ==", () => {
    class MyControlManager extends ControlManager_1.ControlManager {
        createControlTree(state) {
            const topControl = new src_1.ContainerControl({ id: "root" });
            topControl.addChild(new src_1.DateControl({
                id: 'DateControl',
                validation: [src_1.DateControlValidations.PAST_DATE_ONLY]
            }));
            return topControl;
        }
    }
    beforeEach(() => {
        // set now to 2019-01-03
        sinon_1.default.useFakeTimers(new Date('2019-01-03T21:55:38.151Z'));
    });
    afterEach(() => {
        sinon_1.default.restore();
    });
    mocha_1.test("user-defined renderedReason getting translated and used with default InvalidValue prompt", async () => {
        const i18nOverride = {
            en: {
                translation: {
                    DATE_CONTROL_DEFAULT_PROMPT_VALIDATION_FAIL_PAST_DATE_ONLY: 'PAST DATE ONLY PLEASE.'
                }
            }
        };
        const requestHandler = new src_1.ControlHandler(new MyControlManager({ i18nOverride }));
        const invoker = new src_1.SkillInvoker(requestHandler);
        await TestingUtils_1.testTurn(invoker, 'U: 2020', TestingUtils_1.TestInput.of(src_1.SingleValueControlIntent.of(src_1.AmazonBuiltInSlotType.DATE, { 'AMAZON.DATE': '2020' })), 'A: Sorry but that\'s not a valid date because PAST DATE ONLY PLEASE. What date?');
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVuZGVyaW5nLnNwZWMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi90ZXN0L3JlbmRlcmluZy5zcGVjLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQWFBLGlDQUFvQztBQUNwQywwREFBMEI7QUFDMUIsZ0NBQTBQO0FBQzFQLHFEQUFrRDtBQUVsRCxtRUFBZ0U7QUFFaEUsOEVBQTJFO0FBQzNFLHdFQUE0RTtBQUc1RSxNQUFNLG9CQUFxQixTQUFRLGlCQUFPO0lBQ3RDLFNBQVMsQ0FBQyxLQUFtQjtRQUN6QixPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0lBRUQsTUFBTSxDQUFDLEtBQW1CLEVBQUUsYUFBbUM7UUFFM0QsbUVBQW1FO1FBRW5FOzs7OztXQUtHO1FBQ0gsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLDJCQUFxQixDQUFDLElBQUksRUFBRSxFQUFDLFVBQVUsRUFBQyxtQkFBbUIsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLGNBQWMsRUFBRSxvQ0FBb0MsRUFBQyxDQUFDLENBQUMsQ0FBQztRQUVoSzs7OztXQUlHO1FBRUgsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLHFCQUFlLENBQUMsSUFBSSxFQUFFLEVBQUMsVUFBVSxFQUFDLG1CQUFtQixFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUMsQ0FBQyxDQUFDLENBQUM7UUFDcEcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLHFCQUFlLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFFeEQsQ0FBQztJQUVELGlCQUFpQixDQUFDLEtBQW1CO1FBQ2pDLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxjQUFjLENBQUMsS0FBbUIsRUFBRSxhQUFtQztJQUN2RSxDQUFDO0lBRUQsU0FBUyxDQUFDLEdBQWMsRUFBRSxLQUFtQixFQUFFLGVBQXVDO1FBQ2xGLElBQUksR0FBRyxZQUFZLHFCQUFlLEVBQUM7WUFDL0IsZUFBZSxDQUFDLGlCQUFpQixD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QixDQUFDLEVBQUUsQ0FBQywyQkFBcUIsQ0FBQyxJQUFJLEVBQUUsRUFBQyxhQUFhLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxFQUMxRyxpRkFBaUYsQ0FDcEYsQ0FBQztJQUNOLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IDIwMTkgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIikuXG4gKiBZb3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBBIGNvcHkgb2YgdGhlIExpY2Vuc2UgaXMgbG9jYXRlZCBhdFxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBvciBpbiB0aGUgXCJsaWNlbnNlXCIgZmlsZSBhY2NvbXBhbnlpbmcgdGhpcyBmaWxlLiBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWRcbiAqIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmdcbiAqIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IGkxOG5leHQgZnJvbSAnaTE4bmV4dCc7XG5pbXBvcnQgeyBzdWl0ZSwgdGVzdCB9IGZyb20gXCJtb2NoYVwiO1xuaW1wb3J0IHNpbm9uIGZyb20gJ3Npbm9uJztcbmltcG9ydCB7IENvbnRyb2xIYW5kbGVyLCBDb250cm9sUmVzcG9uc2VCdWlsZGVyLCBJbnZhbGlkVmFsdWVBY3QsIFJlcXVlc3RWYWx1ZUFjdCwgU2tpbGxJbnZva2VyLCBTeXN0ZW1BY3QsIFVudXNhYmxlSW5wdXRWYWx1ZUFjdCwgQ29udGFpbmVyQ29udHJvbCwgRGF0ZUNvbnRyb2wsIERhdGVDb250cm9sVmFsaWRhdGlvbnMsIFNpbmdsZVZhbHVlQ29udHJvbEludGVudCwgQW1hem9uQnVpbHRJblNsb3RUeXBlIH0gZnJvbSAnLi4vc3JjJztcbmltcG9ydCB7IENvbnRyb2wgfSBmcm9tICcuLi9zcmMvY29udHJvbHMvQ29udHJvbCc7XG5pbXBvcnQgeyBDb250cm9sSW5wdXQgfSBmcm9tICcuLi9zcmMvY29udHJvbHMvQ29udHJvbElucHV0JztcbmltcG9ydCB7IENvbnRyb2xNYW5hZ2VyIH0gZnJvbSAnLi4vc3JjL2NvbnRyb2xzL0NvbnRyb2xNYW5hZ2VyJztcbmltcG9ydCB7IENvbnRyb2xSZXN1bHQsIENvbnRyb2xSZXN1bHRCdWlsZGVyIH0gZnJvbSAnLi4vc3JjL2NvbnRyb2xzL0NvbnRyb2xSZXN1bHQnO1xuaW1wb3J0IHsgR2VuZXJhbENvbnRyb2xJbnRlbnQgfSBmcm9tICcuLi9zcmMvaW50ZW50cy9HZW5lcmFsQ29udHJvbEludGVudCc7XG5pbXBvcnQgeyBUZXN0SW5wdXQsIHRlc3RUdXJuIH0gZnJvbSAnLi4vc3JjL3V0aWxzL3Rlc3RTdXBwb3J0L1Rlc3RpbmdVdGlscyc7XG5cblxuY2xhc3MgUmVuZGVyaW5nRGVtb0NvbnRyb2wgZXh0ZW5kcyBDb250cm9sIHtcbiAgICBjYW5IYW5kbGUoaW5wdXQ6IENvbnRyb2xJbnB1dCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBoYW5kbGUoaW5wdXQ6IENvbnRyb2xJbnB1dCwgcmVzdWx0QnVpbGRlcjogQ29udHJvbFJlc3VsdEJ1aWxkZXIpOiB2b2lkIHtcblxuICAgICAgICAvLyBBZGRzIHRocmVlIHN5c3RlbSBhY3RzIHRvIHRoZSByZXN1bHQgZm9yIGRlbW9uc3RyYXRpb24gcHVycG9zZXMuXG5cbiAgICAgICAgLyogVGhlIFVudXNhYmxlSW5wdXRWYWx1ZUFjdCBhY3QgaW5jbHVkZXMgc29tZSBzdXJmYWNlIGluZm9ybWF0aW9uIChyZW5kZXJlZFJlYXNvbikgc28gdGhhdCB0aGUgYWN0IGNhbiB1c2UgZGVmYXVsdCByZW5kZXIgbG9naWNcbiAgICAgICAgICogVGhpcyBicmVha3MgdGhlIHNlcGFyYXRpb24gb2YgQ29udHJvbGxlciAmIFZpZXcsIGJ1dCBjYW4gYmUgaGFuZHkgZm9yIHNpbXBsZSBjYXNlcy4gVGhlIHNpbXBsZXN0IGFjdHMsIGUuZy4gVmFsdWVTZXRBY3QsXG4gICAgICAgICAqIGRvbid0IHJlcXVpcmUgYW55IGRhdGEgZm9yIHRoZWlyIGRlZmF1bHRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQcm9kdWN0aW9uIGNvZGUgd2lsbCBsaWtlbHkgbm90IHVzZSB0aGlzIGFwcHJvYWNoLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzdWx0QnVpbGRlci5hZGRBY3QobmV3IFVudXNhYmxlSW5wdXRWYWx1ZUFjdCh0aGlzLCB7cmVhc29uQ29kZTonZXhhbXBsZVJlYXNvbkNvZGUnLCB2YWx1ZTogJzxkdW1teT4nLCByZW5kZXJlZFJlYXNvbjogJ1RoYXQgaW5wdXQgaXMgdW51c2FibGUgZm9yIHJlYXNvbnMnfSkpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSBuZXh0IHR3byBhcmUgJ3B1cmUnIGFjdHMgdGhhdCB3aWxsIGJlIHRyYW5zbGF0ZWQgZHVyaW5nIHRoZSByZW5kZXItcGhhc2UuXG4gICAgICAgICAqIFRoZSBJbnZhbGlkVmFsdWVBY3QgaXMgcmVuZGVyZWQgYnkgdGhpcyBDb250cm9sIGluIHJlbmRlckFjdCgpLiAgVGhpcyBpcyB0aGUgbW9zdCBjb21tb24gYXBwcm9hY2guXG4gICAgICAgICAqIFRoZSBSZXF1ZXN0VmFsdWVBY3QgaXMgcmVuZGVyZWQgYnkgdGhlIENvbnRyb2xNYW5hZ2VyIGluIHJlbmRlcigpLiBUaGlzIGlzIHVzZWQgd2hlbiBmdWxsIGNvbnRyb2wgaXMgbmVjZXNzYXJ5LCBzdWNoIGFzIHRvIHJlbmRlciB0d28gYWN0cyBhcyBhIGNvaGVzaXZlIHBhaXIuXG4gICAgICAgICAqL1xuXG4gICAgICAgIHJlc3VsdEJ1aWxkZXIuYWRkQWN0KG5ldyBJbnZhbGlkVmFsdWVBY3QodGhpcywge3JlYXNvbkNvZGU6J2V4YW1wbGVSZWFzb25Db2RlJywgdmFsdWU6ICc8ZHVtbXk+J30pKTtcbiAgICAgICAgcmVzdWx0QnVpbGRlci5hZGRBY3QobmV3IFJlcXVlc3RWYWx1ZUFjdCh0aGlzLCB7fSkpO1xuXG4gICAgfVxuXG4gICAgY2FuVGFrZUluaXRpYXRpdmUoaW5wdXQ6IENvbnRyb2xJbnB1dCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGFrZUluaXRpYXRpdmUoaW5wdXQ6IENvbnRyb2xJbnB1dCwgcmVzdWx0QnVpbGRlcjogQ29udHJvbFJlc3VsdEJ1aWxkZXIpOiB2b2lkIHtcbiAgICB9XG5cbiAgICByZW5kZXJBY3QoYWN0OiBTeXN0ZW1BY3QsIGlucHV0OiBDb250cm9sSW5wdXQsIHJlc3BvbnNlQnVpbGRlcjogQ29udHJvbFJlc3BvbnNlQnVpbGRlcik6IHZvaWQge1xuICAgICAgICBpZiAoYWN0IGluc3RhbmNlb2YgSW52YWxpZFZhbHVlQWN0KXtcbiAgICAgICAgICAgIHJlc3BvbnNlQnVpbGRlci5hZGRQcm9tcHRGcmFnbWVudCgnVGhlIGN1cnJlbnQgdmFsdWUgaXMgaW52YWxpZC4nKTsgLy8gPDwtLS0tICdyZW5kZXJpbmcgYnkgQ29udHJvbCcuIHRoaXMgaXMgdGhlIG1vc3QgY29tbW9uIGFwcHJvYWNoXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5yZW5kZXJBY3QoYWN0LCBpbnB1dCwgcmVzcG9uc2VCdWlsZGVyKTsgLy8gPDwtLS0tIHN1cGVyLnJlbmRlckFjdCBkZWxlZ2F0ZXMgdG8gYWN0LnJlbmRlcigpLiB0aGlzIGlzICdzZWxmLXJlbmRlcicuIHNlZSBVbnVzYWJsZUlucHV0VmFsdWVBY3QucmVuZGVyKClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgUmVuZGVyaW5nRGVtb0NvbnRyb2xNYW5hZ2VyIGV4dGVuZHMgQ29udHJvbE1hbmFnZXIge1xuXG4gICAgY3JlYXRlQ29udHJvbFRyZWUoc3RhdGU/OiBhbnksIGlucHV0PzogQ29udHJvbElucHV0KTogQ29udHJvbCB7XG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVyaW5nRGVtb0NvbnRyb2woJ3Jvb3QnKTtcbiAgICB9XG5cbiAgICByZW5kZXIocmVzdWx0OiBDb250cm9sUmVzdWx0LCBpbnB1dDogQ29udHJvbElucHV0LCBjb250cm9sUmVzcG9uc2VCdWlsZGVyOiBDb250cm9sUmVzcG9uc2VCdWlsZGVyKTogdm9pZCB8IFByb21pc2U8dm9pZD4ge1xuXG4gICAgICAgIGZvciAoY29uc3QgYWN0IG9mIHJlc3VsdC5hY3RzKSB7XG4gICAgICAgICAgICBpZiAoYWN0IGluc3RhbmNlb2YgUmVxdWVzdFZhbHVlQWN0KXtcbiAgICAgICAgICAgICAgICBjb250cm9sUmVzcG9uc2VCdWlsZGVyLmFkZFByb21wdEZyYWdtZW50KCdIb3cgbWFueSBkdWNrcz8nKTsgLy8gPDwtLS0tICdyZW5kZXIgYnkgQ29udHJvbE1hbmFnZXInLi4gdGhpcyBvZmZlcnMgbWF4aW11bSBwb3dlci5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdC5jb250cm9sLnJlbmRlckFjdChhY3QsIGlucHV0LCBjb250cm9sUmVzcG9uc2VCdWlsZGVyKTsgLy8gPDwtLS0tIHRoZSBnZW5lcmFsIGNhc2UgaXMgdG8gJ3JlbmRlciBieSBDb250cm9sJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogRGVtb25zdHJhdGUgc3RhbmRhcmQgQ29udHJvbFN0YXRlIG9iamVjdCBidXQgd2l0aCBkaWZmZXJlbnQgQ29udHJvbHMgdG8gaGFuZGxlIHRoZW1cbiAqIHRoZSBjaG9pY2Ugb2YgY29udHJvbCB0byB1c2UgaXMgYnkgY29udHJvbFN0YXRlLnR5cGUgYW5kIGJ5IHJlZ2lzdGVyaW5nIHRoZSBjb250cm9sIHR5cGVzXG4gKiB3aXRoIHRoZSBVc2VySW50ZXJmYWNlIHNvIHRoYXQgaXQgY2FuIGZ1bmN0aW9uIGFzIGEgY29udHJvbCBmYWN0b3J5LlxuICovXG5zdWl0ZShcIj09IFJlc3VsdCByZW5kZXJpbmcgKHJlbmRlcmluZ1Jlc3VsdC5zcGVjLnRzKSA9PVwiLCAoKSA9PiB7XG4gICAgdGVzdChcIkRlbW9uc3RyYXRlIFN5c3RlbUFjdCBzZWxmLXJlbmRlciAmIHJlbmRlcmluZyBvdmVycmlkZXMuXCIsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVxdWVzdEhhbmRsZXIgPSBuZXcgQ29udHJvbEhhbmRsZXIobmV3IFJlbmRlcmluZ0RlbW9Db250cm9sTWFuYWdlcigpKTtcbiAgICAgICAgY29uc3QgaW52b2tlciA9IG5ldyBTa2lsbEludm9rZXIocmVxdWVzdEhhbmRsZXIpO1xuICAgICAgICBhd2FpdCB0ZXN0VHVybihcbiAgICAgICAgICAgIGludm9rZXIsXG4gICAgICAgICAgICAnVTogJywgVGVzdElucHV0Lm9mKEdlbmVyYWxDb250cm9sSW50ZW50Lm9mKHt9KSksXG4gICAgICAgICAgICAnQTogU29ycnksIFRoYXQgaW5wdXQgaXMgdW51c2FibGUgZm9yIHJlYXNvbnMuIFRoZSBjdXJyZW50IHZhbHVlIGlzIGludmFsaWQuIEhvdyBtYW55IGR1Y2tzPydcbiAgICAgICAgKTtcbiAgICB9KTtcbn0pO1xuXG5zdWl0ZShcIj09IGkxOG4gb3ZlcnJpZGVzIHNjZW5hcmlvcyA9PVwiLCAoKSA9PiB7XG5cbiAgICBjbGFzcyBNeUNvbnRyb2xNYW5hZ2VyIGV4dGVuZHMgQ29udHJvbE1hbmFnZXIge1xuICAgICAgICBjcmVhdGVDb250cm9sVHJlZShzdGF0ZTogYW55KTogQ29udHJvbCB7XG4gICAgICAgICAgICBjb25zdCB0b3BDb250cm9sID0gbmV3IENvbnRhaW5lckNvbnRyb2woeyBpZDogXCJyb290XCIgfSk7XG4gICAgICAgICAgICB0b3BDb250cm9sLmFkZENoaWxkKG5ldyBEYXRlQ29udHJvbChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAnRGF0ZUNvbnRyb2wnLFxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBbRGF0ZUNvbnRyb2xWYWxpZGF0aW9ucy5QQVNUX0RBVEVfT05MWV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRvcENvbnRyb2w7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgIC8vIHNldCBub3cgdG8gMjAxOS0wMS0wM1xuICAgICAgICBzaW5vbi51c2VGYWtlVGltZXJzKG5ldyBEYXRlKCcyMDE5LTAxLTAzVDIxOjU1OjM4LjE1MVonKSk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgICBzaW5vbi5yZXN0b3JlKCk7XG4gICAgfSk7XG4gICAgdGVzdChcInVzZXItZGVmaW5lZCByZW5kZXJlZFJlYXNvbiBnZXR0aW5nIHRyYW5zbGF0ZWQgYW5kIHVzZWQgd2l0aCBkZWZhdWx0IEludmFsaWRWYWx1ZSBwcm9tcHRcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICBcbiAgICAgICAgY29uc3QgaTE4bk92ZXJyaWRlID0ge1xuICAgICAgICAgICAgZW46IHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICBEQVRFX0NPTlRST0xfREVGQVVMVF9QUk9NUFRfVkFMSURBVElPTl9GQUlMX1BBU1RfREFURV9PTkxZOiAnUEFTVCBEQVRFIE9OTFkgUExFQVNFLidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgcmVxdWVzdEhhbmRsZXIgPSBuZXcgQ29udHJvbEhhbmRsZXIobmV3IE15Q29udHJvbE1hbmFnZXIoeyBpMThuT3ZlcnJpZGUgfSkpO1xuICAgICAgICBjb25zdCBpbnZva2VyID0gbmV3IFNraWxsSW52b2tlcihyZXF1ZXN0SGFuZGxlcik7XG4gICAgICAgIGF3YWl0IHRlc3RUdXJuKFxuICAgICAgICAgICAgaW52b2tlcixcbiAgICAgICAgICAgICdVOiAyMDIwJywgVGVzdElucHV0Lm9mKFNpbmdsZVZhbHVlQ29udHJvbEludGVudC5vZihBbWF6b25CdWlsdEluU2xvdFR5cGUuREFURSwgeydBTUFaT04uREFURSc6ICcyMDIwJyB9KSksXG4gICAgICAgICAgICAnQTogU29ycnkgYnV0IHRoYXRcXCdzIG5vdCBhIHZhbGlkIGRhdGUgYmVjYXVzZSBQQVNUIERBVEUgT05MWSBQTEVBU0UuIFdoYXQgZGF0ZT8nXG4gICAgICAgICk7XG4gICAgfSk7XG59KTsiXX0=